# Model of computation

* The λ calculus can be called the smallest universal programming language.
* The λ calculus consists of a single transformation rule (variable substitution) and a single function definition scheme.
* It was introduced in the 1930s by Alonzo Church as a way of formalizing the concept of effective computability.
* The λ calculus is universal in the sense that any computable function can be expressed and evaluated using this formalism. It is thus equivalent to Turing machines. However, the λ calculus emphasizes the use of transformation rules and does not care about the actual machine implementing them. It is an approach more related to software than to hardware.

* that turned out to be equivalent in computational power to the concept of computation imagined by a queer student of his.
* Lambda calculus, λ-calculus, is a *formal system*[^1] in *mathematical logic* for expressing *computation*, and in that aspect it is equivalent to a Turing machine.
* Lambda calculus may be considered as a formalization of the mathematical concept of function.

* It concerns itself with the minimal set of elements needed to study the essence of the mathematical notion of function, which includes the rules of how a function is defined and how a function is applied to its arguments.

* The fact that the functions are mathematical functions means the notion of a function is exactly how it is represented in mathematics, not how it is represented in programming languages. This means that, unlike in PLs, functions are honest, pure, free of side-effects.

* The fact that the functions are mathematical functions means the notion of a function is exactly how it is represented in mathematics, not how it is represented in programming languages. This means that, unlike in PLs, functions are honest, pure, free of side-effects.


- isomorphism between products and exponentials
- `bᵃ` the number of possible functions from `a` to `b`, `a -> b`
- |Bool -> RGB| = 3²
- |RGB -> Bool| = 2³
- (a ⨯ b) -> c ≅ a -> (b -> c)
- cᵃᵇ = (c -> b)ᵃ = (cᵇ)ᵃ = cᵃᵇ
