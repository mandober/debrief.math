# Elements of lambda application

function argument
fn arg
applicative funarg
fungo fargo

Syntactically, there are functions, i.e. active language elements, that act on the passive language elements, i.e. arguments. But when all there is are functions, we have functions acting on functions, which sometimes calls for a more strict classification. So to distinguish them roles (and considering the expression `f g`), a function in the active position (like `f`), is called an *applicative* or *fungo* (or fapp, funapp, or function-function), and a function in the passive position (like `g`) is a funarg or *fargo* (or function-argument).



On its own, it is an inert, static, language entity. It quickly becomes "active" when another language entity is placed on its right - it applies itself to the entity that becomes its argument (in such a setup, the argument entity is a static one).

The argument may very well be, and it most often is, just another lambda abstraction. Lambda abstractions play for both sides: they play the active role of applicative, and the passive role of arguments to a function as well.
