# Lambda Calculi :: Overview

The topic of numerous calculi based on the lambda calculus is treated here by first covering the original lambda calculus, invented by Alonzo Church in the 1930's.

*The term "lambda calculus"* is usually stated with the null article (no "a" nor "the") since it is a generic term that covers various more-less related versions based on the formalizam that is nowhere precisely described, e.g. in terms of the precise syntax, precedece rules, evaluation order, reduction strategy, etc. It just represents some (more-less particular, or often completely vague) variant based on the original Church's formalism. The qualifiers "untyped" and "typed" barely narrow down the version of LC one has in mind, although the former one refers to the debut version of LC; which soon after being published turned out to be unsound (Curry's paradox), and thus producesa slew of typerd versions.

To show that a specific problem is algorithmically solvable, it is sufficient to provide an algorithm that solves it in a sufficiently precise manner. However, to show that a problem is generally unsolvable by an algorithm, a rigorous formalism is necessary that allows mathematical proofs. That's why there was a need for formalization of the notion of algorithm or effective computation.

*The need for such a formalism* became apparent in the works of David Hilbert (1900) on the foundations of mathematics and Kurt Godel (1931) on the incompleteness of elementary arithmetic. The first investigations in the field were conducted by the logicians Alonzo Church, Stephen Kleene, Emil Post, and Alan Turing in the early 1930s. They provided the foundation of computability theory as a branch of theoretical computer science. The fundamental results established Turing computability as the correct formalization of the informal idea of effective calculation. The results led to Church's thesis stating that "everything computable is computable by a Turing machine". The theory of computability has grown rapidly from its beginning. Its questions and methods are penetrating many other mathematical disciplines. Today, computability theory provides an important theoretical background for logicians and computer scientists. Many mathematical problems are known to be undecidable such as the word problem for groups, the halting problem, and Hilbert's tenth problem.


The original Church's creation was conceived as a logic, a tool for exploring pure mathematical functions, but also as a formualism Church intended as a means of investigating the foundations of mathematics, the path which give rise to using LC to explore *computable functions* as a *method of computation* that will turn out to be equivalent to a Turning machine (and others, all equivalent among them, methods of computation).

The initial incarnations of lambda calculus were all untyped logical formalisms and therefore a nurturing ground for the development of various paradoxes. Seeking to resolve this problems, the next incarnations of lambda calculi introduced types, beginning with the initial typed version called Simply Typed Lambda Calculus (STLC) and authored by Church.

The STLC has introduced a typing style, later referred as *typing à la Church*, in which all the terms have manually assigned types, so the process of type-checking (in PLs based on this theory) need not reconstruct the types first. This style puts more burdon on the user, requiring a lot of manual work.

An alternative typing-style that was invented around the same time is called *typing à la Curry*, in which the code looks far more cleaner, having freed the users from having to annotate everything. This style puts more burdon on the compiler, requiring one capable of reconstructing the types first, before it can proceed with the usual type-checking.

Somewhere in the middle between these two typing approaches are typing styles that allow the user to elide typing the terms which type can be inferred. Depending on the variant and complexity of the typing system, compilers will put more or less typing obligations on the user. The goldy locks point where the compiler requires no user intervention, yet features a sufficiently advanced type system, is well-established and PLs sporting such a type system already exist. However, attempts to stretch the type system beyond that point by adding advanced typing features (like type classes, type famillies, indexed types, GADTs, type refinement, type constraints) means the user will have to take care of the typing overspilt.

These advanced systems based on lambda calculus are collectivelly named typed lambda calculi, and they include features that are usually sufficiently orthogonal that the packs of features can be explored together. Advancing the features in different dimensions is particularly examined and descibed in terms of the *lambda cube*, which is a diagram and a system for organizing these orthogonal typing enhancements. One axes is about adding polymorphism, an axes for adding type constructors (meaning type functions), an axes for adding dependent types, and so on, with the possiblility to combine the features of different axis.
