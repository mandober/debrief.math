# Finite automata

(from the book "Introduction to Automata Theory, Languages, and Computation", 3rd Edition, John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman, 2006)

## Models of computation

Finite automata is a model of computation. Computation in finite automata involves transitions between states in response to an input symbol. The transition to the next state depends on (the current state and) the input symbol.

There are different versions of finite automata. Generally, finite automata do not produce output: they only accept or reject an input string, and in that they define the set containing all of the strings of some language. *Finite state transducers* (FST) are finite automata that does produce output. While being useful for certain kinds of tasks, finite automata have very limited computational power due to the finite number of states and because it has no memory. Adding memory to a finite automaton yields *Turing machine*.

## States, input and transitions

A key component of a finite automata is a finite collection of states and for this reason they are called *finite state machines* (FSM). The fact that the collection of states is finite is important as it limits their expressive power.

A FSM is `‚ü®Q, Œ£, Œ¥, S, F‚ü©`, where
- `Q`  is the set of states
- `Œ£`  is the finite alphabet of input symbols
- `Œ¥`  is the transition function, `Œ¥ : Q ‚®Ø Œ£ ‚Üí Q`
- `S`  is the finite set of initial states; in DFA, `S = {q‚ÇÄ}` or jusr `q‚ÇÄ`
- `F`  is the set of accepting states, F ‚äÜ Q

*Finite set of states*, `Q`: a FSM has `n = |Q|` states (with `n >= 1`), but not all states may be interconnected; some states may be completely separate and some may be unreachable from some other states (this is rarely practical, so usually all states are reachable).

*Alphabet* `Œ£`: a FMS recognizes strings formed from an alphabet `Œ£`. Therefore, a FSM is said to recognize a language of strings over an alphabet Œ£. That way, a FSM also defines the language `L` of string over an alphabet Œ£. An alphabet is a set of symbols (characters), e.g. Œ£ = {0, 1}. The *input* to FSM is a string fed one character at a time.

*Language* `L` over an alphabet `Œ£` is a set of all well-formed strings `w` composed of characters in Œ£. A string in L may be a sequence of chars such as 01, 0110, 1001, etc. Each language specifies the rules that determine which strings are valid (well-formed). For example, a language over an alphabet Œ£ = {0,1} may only admit strings that have the same number of 0's and 1's. Or a language `L` may consist only of strings `w` of even length, which may be denoted in set-builder notation as `L = { w ‚àà {0,1}‚àó : |w| is even }`.

FSM can only recognize *regular languages*. FSM may be a DFA or a NFA, but these are equivalent, DFA ‚âÖ NFA. Furthermore, regular expressions only describe a regular language, so there is also an equivalence **DFA ‚âÖ NFA ‚âÖ RE**, and they all recognize (define) regular languages only.

*Transition function*, `Œ¥`, specifies all the transitions a FMS can make from any state. `Œ¥ : Q ‚®Ø Œ£ ‚Üí Q` means that `Œ¥` takes the current state and the current input character as arguments and gives back the state to transition to. The transition function `Œ¥` is a total function - for each state the transition is defined for each input character. If `|Œ£| = k`, then each state must have all `k` transitions (outgoing arrows) specified.

*Starting (initial) state*, `q‚ÇÄ`, is the state in which a FSM starts. There is always a single starting state `q‚ÇÄ ‚àà Q`.

*Accepting (final) states*, `F`, are all the states that accept an input string. A FSM must consume all the characters of the input string `w`, ending up (after consumming the final character of `w`) in one of the final states, so it can be said that it accepts `w`. There are usually more than 1 accepting states, but 0 is not excluded - it just doesn't make for an exciting FSM since everything is rejected. The states `Q ‚àñ F` are *rejecting states*.

Note: In some books, accepting states are called final states, which is misleading because the computation can continue after a final state is reached. In fact, there is nothing preventing, and it is often necessary, for an accepting state to have transitions to other states. Only if the last char was consumed and a FSM finds itself in an accepting state will the string be accepted. But if a FSM find itself in an accepting state, but the string is not yet consumed, the process proceeds normally. 


**DFA** is decidable in that any state must define a transition on each character in the alphabet Œ£ (it may take the same transition on multiple characters), and, it can only make a transition by consuming a character (DFA must consume an input character to take a transition). To recognize a string of length `m`, a DFA must have at least `m‚Åü+‚Åü1` states.

**NFA** is undecidable in that there may be multiple transitions available on the same input character, as well as Œµ-transitions that enable it move between states without consuming a character. NFA can make a transition without consuming an input character - this is modelled via *Œµ-transitions* that may be taken by "consuming" the empty string (Œµ).


In a *FSM diagram*, states are modelled by circles, and transitions by arrows that connect the circles. The arrows between states are labelled by the input symbol that causes the automaton to move from the state at the tail of the arrow to the state at the head of the arrow. The initial state is indicated by an arrow coming into the initial state `q‚ÇÄ` out of nowhere. Final states are indicated by doubly-oulined circles. Automaton can *loop* back to the current state on a character, as indicated in a diagram by a looping (identity) arrow.


Each finite automaton *partitions the set of all possible input strings* into
two subsets: the strings that it accepts and the strings that it rejects.

The set of strings that a finite automaton `M` accepts is called the *language accepted (recognized) by `M`*, denoted `L(M)`.

The language accepted by a finite automaton is often an infinite set, even though its set of states and everything else about it is finite.

## Deterministic finite automata

A finite automaton that is deterministic is called a deterministic finite automaton (DFA).

A finite automaton is deterministic if:
- it has 1 start state
- it has exactly 1 transition from each state for each input symbol
- it has no Œµ-transitions

The set of input symbols allowed by a DFA is called an alphabet, and it is required to be finite. If `Œ£` is an alphabet of a DFA named `M`, then `L(M)` is a subset of `Œ£‚àó`, the set of strings including the empty string over `Œ£`.

When building an DFA, it's often necessary to include non-accepting black hole states from which there is no way of reaching an accepting state. Under the *black hole convention*, such states can be omitted to simplify the diagram. This leads to a diagram in which there is at most one transition from each state for each symbol of the alphabet, rather than exactly one. In a DFA, one transition from every state is required for every symbol of the alphabet. The transitions that are absent when a black hole is omitted can easily be recreated by adding an additional state with all of the missing transitions leading to that state.

## DFA and NFA

**Nondeterministic Finite Automaton** is `‚ü®Q, Œ£, Œ¥, S, F‚ü©`
- `Q`  is the finite set of states
- `Œ£`  is the finite alphabet of input symbols
- `Œ¥`  is the *transition relation*, `Œ¥ ‚äÜ Q‚Åü‚®Ø‚ÅüŒ£‚Åü‚®Ø‚ÅüQ`
- `S`  is the finite *set of initial states*, `S ‚äÜ Q`
- `F`  is the set of accepting states, `F ‚äÜ Q`

**Deterministic Finite Automaton** is `‚ü®Q, Œ£, Œ¥, S, F‚ü©`
- `Q`  is the finite set of states
- `Œ£`  is the finite alphabet of input symbols
- `Œ¥`  is the *transition function*, `Œ¥ : Q‚Åü‚®Ø‚ÅüŒ£ ‚Üí Q`
- `q‚ÇÄ` is the *single initial state*, `S = {q‚ÇÄ}` (or `S = q‚ÇÄ`) and `S ‚äÜ Q`
- `F`  is the set of accepting states, `F ‚äÜ Q`

The difference between NFA and DFA is that NFA can have more than one starting state: it has a finite set of states `S` (where S ‚äÜ Q). DFA has a single start state, which usually means `S = q‚ÇÄ`, i.e. a single state `q‚ÇÄ` is mentioned instead of the set `S`. However, for generalization over the two automatons, we can say that `S = {q‚ÇÄ}`.

Another difference is that `Œ¥` is a *transition relation* in NFA, `Œ¥ ‚äÜ Q‚®ØS‚®ØQ`, but *transition function* in DFA, `Œ¥ : Q‚Åü‚®Ø‚ÅüŒ£ ‚Üí Q`.

## Generalizing transition relation

To unify both NFAs and DFAs, we need to generalize the transition relation of NFA and transition function of DFA. Since all functions are relations, we can generalize `Œ¥` to be a relation, but we can also go the other way and generalize `Œ¥` to always be a function. In case of DFA, `Œ¥` remains a total function `Œ¥ : Q ‚®Ø Œ£ ‚Üí Q`, but in case of NFA, we can express a transition relation as a function that returns a set of states, `ùí´(Q)`, instead of only a single state `Q`.

`Œ¥ : Q ‚®Ø Œ£ ‚Üí ùí´(Q)`

That is, a function `Œ¥` will than take a pair of a state and an input char, `(q·µ¢, c‚±º)`, and return a set of states, `(q‚ÇÅ, ‚Ä¶, q‚Çô)`, each of which can be transitioned to from the state `q·µ¢` on symbol `c‚±º`. The return type is the powerset of states, `ùí´(Q)`, since a NFA can have any number of transitions from one state to any and all other states. ùí´(Q) also contains ‚àÖ for case a state in NFA has no transitions, but also to model *Œµ-transitions* which consume no input (i.e. they consume the empty string, `Œµ`).

```hs
DFA  Œ¥ : Q ‚®Ø Œ£ ‚Üí Q
NFA  Œ¥ : Q ‚®Ø Œ£ ‚®Ø Œ£
----------------------
FSA  Œ¥ : Q ‚®Ø Œ£ ‚Üí ùí´(Q)
```

```hs
-- In DFA, Œ¥ retunrs a single state
Œ¥ :: Q ‚®Ø Œ£ ‚Üí Q
Œ¥ q c | q == 0 | c == "0" = q‚ÇÅ
               | c == "1" = q‚ÇÇ
      | q == 1 | c == "0" = q‚ÇÄ
               | c == "1" = q‚ÇÇ
      | q == 2 | c == "0" = q‚ÇÄ
               | c == "1" = q‚ÇÅ

-- In DFA, Œ¥ retunrs a set of states
Œ¥ :: Q ‚®Ø Œ£ ‚Üí ùí´(Q)
Œ¥ q c | q == 0 | c == "0" = (q‚ÇÅ, q‚ÇÉ)
      | q == 1 | c == ""  = (q‚ÇÄ)
               | c == "0" = ()
               | c == "1" = (q‚ÇÄ, q‚ÇÅ, q‚ÇÇ)
      | q == 2 | c == ""  = (q‚ÇÄ, q‚ÇÅ, q‚ÇÇ)
```

‚ü®q·µ¢, s‚±º‚ü© ‚üº ‚ü®q‚ÇÅ, ‚Ä¶, q‚Çô‚ü©
Œ¥ ‚äÜ Q ‚®Ø Œ£ ‚®Ø Q, Œ¥ = { (q·µ¢, s‚Çñ, q‚±º) | q‚±º is }
Œ¥ : Q ‚®Ø Œ£ ‚Üí Q, Œ¥ = { ((q·µ¢, s‚Çñ), q‚±º) }
Œ¥ : Q ‚®Ø Œ£ ‚Üí ùí´(Q), Œ¥ = { ((q·µ¢, s‚Çñ), (q ≤‚ÇÄ, ‚Ä¶, q ≤‚Çô)) }


(Definition: **relation delta as function**)   
A function `Œ¥ : Q √ó Œ£ ‚Üí Q` is a *relation* `Œ¥ ‚äÜ Q√óŒ£√óQ` such that for each `q ‚àà Q` and `a ‚àà Œ£`, if `(q,a,q') ‚àà Œ¥` and `(q,a,q") ‚àà Œ¥` then `q' = q"`. It is a *total function* if for each `q ‚àà Q` and `a ‚àà Œ£`, there is some `q'` such that `(q, a, q') ‚àà Œ¥`.

The first requirement says that the diagram contains only one start state, and the second requirement says that there is one and only one transition from each state for each input symbol. It's convenient to give the transition function `Œ¥` in the form of a table, with rows corresponding to states and columns corresponding to input symbols. Then the second requirement means there will be exactly one state in each position of the table.

What happens when a FSM `M` reads a string of symbols, and what it means for `M` to accept a string, is explained by the next definition.


(Definition: **delta star function**)    
Let `M = (Q, Œ£, d, {q‚ÇÄ}, F)` be a DFA. Then the transition function `Œ¥ : Q √ó Œ£ ‚Üí Q` is extended to a function `Œ¥‚àó : Q √ó Œ£‚àó ‚Üí Q` on strings over `Œ£`, including Œµ, as follows:
1. ‚àÄq ‚àà Q, `Œ¥‚àó(q, Œµ) = q`
2. ‚àÄq ‚àà Q, ‚àÄc ‚àà Œ£ and ‚àÄw ‚àà Œ£‚àó, `Œ¥‚àó(q, c‚Åüw) = Œ¥‚àó(Œ¥(q,c), w)`

A string `w ‚àà Œ£‚àó` is *accepted* by `M` iff `Œ¥‚àó(q‚ÇÄ, w) ‚àà F`.

The definition of the extended transition function `Œ¥‚àó` is by recursion. The first case says what it does for Œµ. The second case says what it does for a string `c‚Åüw` consisting of a symbol `c` followed by a string `w`, in terms of what it does for `w`: first move to the state indicated by `Œ¥` for the symbol `c`, and then proceed from there according to `Œ¥‚àó` for `w`.

Example of `M` accepting the string "aaab", one step at a time:

```hs
  Œ¥‚àó(0, aaab)
= Œ¥‚àó(Œ¥(0, a), aab)   -- Œ¥(0, a) = 1
= Œ¥‚àó(1, aab)
= Œ¥‚àó(Œ¥(1, a), ab)    -- Œ¥(1, a) = 4
= Œ¥‚àó(4, ab)
= Œ¥‚àó(Œ¥(4, a), b)     -- Œ¥(4, a) = 4
= Œ¥‚àó(4, b)
= Œ¥‚àó(Œ¥(4, b), e)     -- Œ¥(4, b) = 5
= Œ¥‚àó(5, e)
= 5
```

The string `"aaab" ‚àà Œ£‚àó` is accepted because `Œ¥‚àó(0, aaab) = 5` and `5 ‚àà F`.


It is interesting to inspect the sequence of states that are visited by a DFA during the computation.

(Definition: **Tracing**)    
Let `M = (Q, S, d, {q0}, F)` be a DFA, and let `s = a‚ÇÅa‚ÇÇ‚Ä¶a‚Çô` be a string in `Œ£‚àó`, with `a·µ¢ ‚àà Œ£` for each 1 ‚â§ i ‚â§ n. The trace of `M` on `s` is the sequence `q‚ÇÄ, q‚ÇÅ, ‚Ä¶, q‚Çô` of states, where
```
    a‚ÇÅ      a‚ÇÇ     a‚Çô
q‚ÇÄ ---> q‚ÇÅ ---> ‚ãØ ---> q‚Çô ‚àà Œ¥
```

For example, in the last example, the trace of `M` on "aaab" is (0,1,4,4,5). The first state in the trace is the start state q‚ÇÄ and the last state in the trace is the state that is reached when the input string is exhausted. The string is accepted iff that state is an accepting state.


Definition: **Regular language**     
Let `Œ£` be an alphabet. 
>Any set of strings `L ‚äÜ Œ£‚àó` is called a language. 
The language accepted by a DFA `M` 
with alphabet Œ£ 
is the set `L(M) ‚äÜ Œ£‚àó` 
of strings accepted by `M`. 
>A language `L` is regular 
>if there is some DFA `M` 
>such that `L = L(M)`.


## Complement DFA

Let a DFA `M` accept a certain language `L(M)`. One of the things we can do with `M` is combine it with other DFAs to make it accept a different language. This allows us to build complicated DFAs out of simple ones.

**Complement**: changing `M` so that it accepts the complement of `L(M)` with respect to `Œ£‚àó`. That is, it should accept the strings in `Œ£‚àó` that are not accepted by `M`. To do this, we just *swap accepting and rejecting states*.

The complement of a DFA `(Q, Œ£, Œ¥, S, F)` is `(Q, Œ£, Œ¥, S, Q‚Åü‚àñ‚ÅüF)`. Then `L(M)` is the complement of `L(M)` with respect to `Œ£‚àó`. This shows that the complement of a regular language is also regular. In other words, 
>the set of regular languages is closed under complement.

## Product DFA

Given two DFAs, `M` and `M π`, that accept the languages `L(M)` and `L(M π)` over the same alphabet `Œ£`, how can we build a FSM to accept their intersection, `L(M) ‚ãÇ L(M π)`?

The intuition behind the *product construction* is: run `M` and `M π` in parallel, accepting a given string `s ‚àà Œ£‚àó` iff it is accepted by both M and M π. If `s` is accepted by M then `s ‚àà L(M)`, and if `s` is accepted by M π then `s ‚àà L(M π)`, so being accepted by both means that `s ‚àà L(M) ‚ãÇ L(M π)`.

We need a single DFA that simulates the actions of M and M π running in parallel. The following definition shows that the set of regular languages is closed under intersection.

>Regular languages are closed under intersection.

(Definition: **Product construction**)    
The product of DFAs 
`M  = (Q, Œ£, Œ¥, {q‚ÇÄ}, F)` and 
`M π = (Q π,Œ£ ,Œ¥ π,{q‚ÇÄ π},F π)` 
is 
`M‚Åü‚®Ø‚ÅüM π = (Q‚Åü‚®Ø‚ÅüQ π, Œ£, Œ¥‚Åü‚®Ø‚ÅüŒ¥ π, {(q‚ÇÄ, q‚ÇÄ π)}, F√óF π)`, 
where the transition function 
`Œ¥‚Åü‚®Ø‚ÅüŒ¥ π : (Q‚Åü‚®Ø‚ÅüQ π)‚Åü‚®Ø‚ÅüŒ£ ‚Üí (Q‚Åü‚®Ø‚ÅüQ π)` 
is defined by 
`(Œ¥‚Åü‚®Ø‚ÅüŒ¥ π)((q, q π), a) = (Œ¥(q, a), Œ¥ π(q π, a))` 
and the set of accepting states is 
`F‚Åü‚®Ø‚ÅüF π = { (q, q π) ‚àà Q‚Åü‚®Ø‚ÅüQ π | q ‚àà F ‚ãÄ q π ‚àà F π }`


The states of `M‚Åü‚®Ø‚ÅüM π` are pairs consisting of a state from M and a state from M π. The product DFA being in state `(q, q π)` corresponds to M being in state q and M π being in state q π. Then reading a symbol a ‚àà Œ£ causes a transition to 
`(Œ¥(q, a), Œ¥ π(q π, a))`, which corresponds to M moving to state `Œ¥(q, a)` and M π moving to state `Œ¥ π(q π, a)`.

Since the start state of `M√óM π` is `(q‚ÇÄ, q‚ÇÄ π)`, and its accepting states are pairs `(q, q π)` such that `q ‚àà F` and `q π ‚àà F π`, computations of `M√óM π` correspond exactly to M and M π running in parallel, side by side, and accepting a string only when both M and M π would have accepted it.

## Sum DFA

Given two DFAs, `M` and `M π`, that accept the languages `L(M)` and `L(M π)` over the same alphabet `Œ£`, how can we build a FSM to accept their union, `L(M) ‚ãÉ L(M π)`?

The difference between the union and intersection machines is in the set of accepting states. In the case of the intersection of languages, in order to accept a string we needed both M and M π to accept it. In the case of the union, we need either machine one to accept it.

>Regular languages are closed under union.

(Definition: **Sum construction**)    
The product of DFAs 
`M  = (Q, Œ£, Œ¥, {q‚ÇÄ}, F)` and 
`M π = (Q π,Œ£ ,Œ¥ π,{q‚ÇÄ π},F π)` 
is 
`M‚Åü+‚ÅüM π = (Q‚Åü‚®Ø‚ÅüQ π, Œ£, Œ¥‚Åü‚®Ø‚ÅüŒ¥ π, {(q‚ÇÄ, q‚ÇÄ π)}, F‚Åü+‚ÅüF π)`, 
where the transition function 
`Œ¥‚Åü‚®Ø‚ÅüŒ¥ π : (Q‚Åü‚®Ø‚ÅüQ π)‚Åü‚®Ø‚ÅüŒ£ ‚Üí (Q‚Åü‚®Ø‚ÅüQ π)` 
is defined by 
`(Œ¥‚Åü‚®Ø‚ÅüŒ¥ π)((q, q π), a) = (Œ¥(q, a), Œ¥ π(q π, a))` 
and the set of accepting states is 
`F‚Åü+‚ÅüF π = { (q, q π) ‚àà Q‚Åü‚®Ø‚ÅüQ π | q ‚àà F ‚ãÅ q π ‚àà F π }`

## Nondeterministic Finite Automata

The restrictions of DFAs meant that no decisions are required: there is one state to start from, and there is always one transition available from every state for each input symbol. Relaxing these restrictions gives a NFA, which can have more than one start state and where there can be any number of transitions from any state on any input symbol.

One way of thinking of NFAs is that it offers many choices, and a series of decisions is required during computation. This leads to different possible computations, having potentially different outcomes (accept or reject). *NFA accepts an input if at least one series of decisions leads it to accept*. Equivalently, we can think about NFAs as trying all the possible choices simultaneously, and accepting an input if at least one of them results in the NFA ending up in an accepting state.

Creating an NFA that accepts a given language is often much easier than creating a DFA. Surprisingly, however, it turns out that non-determinism actually gives us no additional power:
> Every NFA can be converted to a DFA that accepts the same language.

In fact, even adding more non-determinism to NFAs in the form of Œµ-transitions, which give us the ability to move freely between states without consuming input symbols, gives no additional power.

NFAs, the proof that every NFA can be converted to an equivalent DFA, as well as the Pumping Lemma, are due to 1976 Turing Award winners Michael Rabin and Dana Scott.
