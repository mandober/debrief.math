# Regular Language

https://en.wikipedia.org/wiki/Regular_language

In theoretical computer science and formal language theory, particularly in the filed of theory of computation, a **regular language** is a formal language that can be defined by a *regular expression*.

This includes the strict, theoretical computer science definition of regular expression, and not the relaxed notion of regexes found in modern languages that are augmented with features that allow the recognition of even some nonregular languages (lookback, lookahead, etc).

In the strict sense, *regular expressions*, `r`, only recognize:
- `∅`       (empty lang)
- `{ε}`     (empty string lang)
- `.`       (a single character)
- `r₁ ⋃ r₂` (union of regexes)
- `r₁ • r₂` (concatenation of regexes)
- `r⭑`      (Kleene star operator on a regex)

Alternatively, a **regular language** can be defined as a language recognized by a *finite automaton* (DFA or NFA, but DFA ≅ NFA).

The equivalence of regular expressions and finite automata is known as *Kleene's theorem*.

In the *Chomsky hierarchy*, regular languages are the languages generated by *Type-3 grammars* (regular grammars).

## Contents

- Formal definition
- Examples
- Equivalent formalisms
- Closure properties
- Decidability properties
- Complexity results
- Location in the Chomsky hierarchy
- The number of words in a regular language
- Generalizations


## Formal definition

Collection of regular languages over an alphabet `Σ` is defined recursively:
1. `∅`            The empty language is a regular language
2. `{ε}`          The empty string language is a regular language
3. ∀α ∈ Σ. `{α}`  The singleton language `{α}` is a regular language

If L₁ and L₂ are regular languages, then so is their
4. `L₁ ⋃ L₂`          (union)
5. `L₁ L₂` or `L₁ • L₂` (concatenation)
6. `L⭑`               (Kleene star, iteration)

No other languages over Σ are regular.

Thus, regular languages are exactly those language describable by regular expressions since these 6 axioms state exactly what regexes can recognize.

In other words, the *basic regular expressions* are capable of recognizing the empty language, ∅, the empty string language, {ε}, any singleton language (single-character language), {α}. The 3 *regular operations* can then be applied to the basic regexes to enlarge the set of recognized languages; the 3 regular operations are union, concatenation and iteration (the star operator).

* Regular languages are recognized by regexes.
* Regular languages are recognized by DFAs.
* DFAs are equivalent to NFAs.

A NFA can usually more succintly describe a language, and then it can be converted into a DFA used to build a regex; a regex is a "compiled" DFA.

## Examples

>All finite languages are regular.

In particular,
- the empty language `{} = ∅` is regular.
- the empty string language `{ε} = ∅⭑` is regular.
- any single-string language `{α}` is regular, (where `α ∈ Σ`)

Examples of languages over the alphabet `Σ = {a, b}` include languages consisting of all strings of the form:
- even number of `a`'s (re = `(aa)⭑`) is regular
- a number of `a`'s followed by a number of `b`'s, (re = `a⭑b⭑`) is regular
- `{ aⁿbⁿ | n >= 0 }` is NOT regular
- the same number of `a`'s and the same number of `b`'s is NOT regular

The language containing the set of strings of the form `{ aⁿbⁿ | n >= 0 }` is not regular since it cannot be recognized by a finite automaton; this is because a finite automaton has finite memory and it cannot remember the number of `a`'s seen.

## Equivalent formalisms

A regular language satisfies the following equivalent properties:

1. recognized by a regular expression

2. accepted by a NFA
  - (1) ⇒ (2) by Thompson's construction algorithm
  - (2) ⇒ (1) by Kleene's algorithm or using Arden's lemma

3. accepted by a DFA
  - (2) ⇒ (3) by the powerset construction
  - (3) ⇒ (2) since the definition of DFA is stronger than the def of NFA

4. generated by a regular grammar
  - (2) ⇒ (4) see Hopcroft, Ullman (1979), Thm 9.2
  - (2) ⇒ (4) see Hopcroft, Ullman (1979), Thm 9.1
  in "Introduction to Automata Theory, Languages, and Computation"

5. accepted by an alternating finite automaton

6. accepted by a two-way finite automaton

7. generated by a prefix grammar

8. accepted by a read-only Turing machine

9. defined in monadic second-order logic 
   (Büchi-Elgot-Trakhtenbrot theorem)

10. recognized by some finite syntactic monoid `M`, 
    meaning, it is the preimage `{w ∈ Σ* | f(w) ∈ S}` 
    of a subset `S` 
    of a finite monoid `M` 
    under a monoid homomorphism `f: Σ* → M` 
    from the free monoid on its alphabet
  - (3) ⇔ (10) by the Myhill-Nerode theorem

11. the number of equivalence classes of its syntactic congruence is finite. (This number equals the number of states of the minimal deterministic finite automaton accepting L)
  - `u ~ v` is defined as: `u w ∈ L ⇔ v w ∈ L`, for all `w ∈ Σ*`
  - 3. ⇔ 11. see the proof in the Syntactic monoid article, and see p.160 in Holcombe, W.M.L. (1982). Algebraic automata theory.
