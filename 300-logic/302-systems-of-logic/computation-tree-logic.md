# Computation tree logic

https://en.wikipedia.org/wiki/Computation_tree_logic

**Computation tree logic (CTL)** is a *branching-time logic*, meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized.

CTL is used in *formal verification* of software or hardware artifacts, typically by software applications known as *model checkers*, which determine if a given artifact possesses *safety or liveness properties*.

For example, CTL can specify that when some initial condition is satisfied (e.g. all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g. dividing a number by zero or two cars colliding on a highway).

In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property.

Computation tree logic belongs to a class of *temporal logics* that includes *linear temporal logic (LTL)*. Although there are properties expressible only in CTL and properties expressible only in LTL, all properties expressible in either logic can also be expressed in `CTL*`.

## Contents

- 1. History
- 2. Syntax of CTL
- 3. Operators
  - 3.1. Logical operators
  - 3.2. Temporal operators
  - 3.3. Minimal set of operators
- 4. Semantics of CTL
  - 4.1. Definition
  - 4.2. Characterisation of CTL
  - 4.3. Semantic equivalences
- 5. Examples
- 6. Relations with other logics
- 7. Extensions


## History

CTL was first proposed by Edmund M. Clarke and E. Allen Emerson in 1981, who used it to synthesize so-called synchronisation skeletons, i.e abstractions of concurrent programs.

Since the introduction of CTL, there has been debate about the relative merits of CTL and LTL. Because it is more computationally efficient to model check, CTL has become more common in industrial use, and many of the most successful model-checking tools use CTL as a specification language.

## Syntax of CTL

The language of wff for CTL is generated by the following grammar:

```
φ := ⊥ | ⊤ | p
   | (¬φ) | (φ ∧ φ) | (φ ∨ φ) | (φ ⇒ φ) | (φ ⇔ φ)
   | AX φ | ∀ ○ φ
   | EX φ | ∃ ○ φ
   | AF φ | ∀ ◻ φ
   | EF φ | ∃ ◻ φ
   | AG φ | ∀ ◊ φ
   | EG φ | ∃ ◊ φ
   | A [φ U φ]
   | E [φ U φ]
```

where `p` ranges over a set of atomic formulas. It is not necessary to use all connectives - for example, `{ ¬, ∧, AX, AU, EU }` comprises a complete set of connectives, and the others can be defined using them.
- `A` means 'along ALL paths' (*inevitably*)
- `E` means 'along at least one (EXISTS) path' (*possibly*)

For example, the following is a well-formed CTL formula: EF (EG p ⇒ AF r). The following is not a well-formed CTL formula: EF (r U q) because `U` can occur only when paired with an `A` or an `E`.

CTL uses atomic propositions as its building blocks to make statements about the states of a system. These propositions are then combined into formulas using logical operators and temporal operators.

## Operators

### Logical operators

The logical operators are the usual ones: ¬, ∨, ∧, ⇒, ⇔. Along with these operators CTL formulas can also make use of the boolean constants true (⊤) and false (⊥).

### Temporal operators

The temporal operators are the following:

Quantifiers over paths
- `A Φ` All: `Φ` must hold on all paths starting from the current state
- `E Φ` Exists: starting from current state, a path where `Φ` holds exists

Path-specific quantifiers
- `X φ` _Next_: φ must hold at next state (sometimes denoted N), `◯`
- `F φ` _Finally_: φ eventually has to hold (somewhere on subsequent path), `◻`
- `G φ` _Globally_: φ has to hold on the entire subsequent path, `◊`

- `φ U ψ` _Until_: φ has to hold at least until at some position ψ holds.
  Implies that ψ will be verified in the future.

- `φ W ψ` _Weak until_: φ has to hold until ψ holds. Also called _unless_. 
  Difference from `U` is no guarantee that ψ will ever be verified.

>In CTL, operators must always be grouped in pairs:
>a *path* operator followed by a *state* operator.

In `CTL*`, the temporal operators can be freely mixed. 
`CTL*` is strictly more expressive than CTL.

### Minimal set of operators

In CTL there are minimal sets of operators. All CTL formulas can be transformed to use only those operators. This is useful in model checking. One minimal set of operators is: `{ true, ∨, ¬, EG, EU, EX }`.

Some of the transformations used for temporal operators are:
- EFφ      == E[true U(φ)]   ( because Fφ == [true U(φ)] )
- AXφ      == ¬EX(¬φ)
- AGφ      == ¬EF(¬φ)     == ¬ E[true U(¬φ)]
- AFφ      == A[true U φ] == ¬EG(¬φ)
- A[φ U ψ] == ¬( E[¬ψ U ¬(φ ∨ ψ)] ∨ EG(¬ψ) )


## Semantics of CTL
### Definition
### Characterisation of CTL
### Semantic equivalences
## Examples
## Relations with other logics
## Extensions


## Refs

CTL - Andrei Popescu (7 videos)
https://www.youtube.com/playlist?list=PLMBx8HjvK764YpZVFUJ1HEyvrwbW2pChA
