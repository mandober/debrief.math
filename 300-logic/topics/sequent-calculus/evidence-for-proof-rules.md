# Evidence for proof rules

The intuition behind the Gentzen system by exploring the evidence constructed by the proof rules. This explicit construction of evidence is not a part of the original formulation of the Gentzen systems and is added to the rules here only as auxillary information towards building the better intuition for the system.

Considering the top-down inference rules for propositional logic, each rule emphasizes the formula to be decomposed and maintains the context of the remaining hypotheses (`Γ` or `H`) and alternative goals (`Δ` or `G`).

## Right conjunction, `R∧`

The rule `R∧` decomposes a conjunction `A ∧ B` in the conclusions and returns two subgoal sequents: one in which we have to prove `A` and another in which we have to prove `B`. In each subgoal sequent the remaining assumptions and conclusions remain unchanged.

```hs
H ⊢ G, A ∧ B
------------- R∧
H ⊢ G, A
H ⊢ G, B
```

To explain the correctness of this rule, we need to look at the evidence. Assume we have constructed a proof for `H ⊢ G, A`, and a proof for `H ⊢ G, B`.

Then   the first proof gives us some evidence `a` for the truth of `A`, 
while the second proof gives us some evidence `b` for the truth of `B` 
(each in the context of `H` and `G`).

Putting the evidence together gives us evidence for the truth of `A ∧ B`, because the semantics of the conjunction states that `A ∧ B` is true only in case both `A` and `B` are true.

We can say that the pair `(a, b)` is the evidence for the truth of `A ∧ B` and write the rule `R∧` together with the *associated evidence construction* as:

```hs
R∧  H ⊢ G, A ∧ B     evidence: (a, b)
      H ⊢ G, A       evidence for A: a
      H ⊢ G, B       evidence for B: b
```

While the rule describes a *top-down decomposition* of sequents into subgoal sequents, it describes the *bottom-up evidence construction*.

It states that in order to prove `A ∧ B`, we have to separately prove `A` and `B`, and once we do, we can compose `a` and `b` evidence into a pair `(a, b)` as the evidence for `A ∧ B`.

Thus, the evidence for the validity of a formula can only be constructed once the top-down proof is complete, i.e. if each branch is closed by the axiom rule.

## The axiom rule, `Ax`

The axiom rule is used to prove the validity of a sequent without generating further subgoals. If the same formula is present in both hypotheses and conclusions (possibly with some other formulas), then the sequent is valid.

Although the correctness of this rule is obvious, it is worth looking at the evidence constructed by it. Essentially, we need to provide information about the assumption that has been used to prove the conclusion.

We need a way to refer to a specific formula within a cedent, and for that purpose we could use indices, but they make no sense if we represent cedents using multisets. So we'll use labels to keep track of formulas, which are also handy for tracking the formulas generated by decomposition of larger ones.

If we label the assumption `A` by `a`, then this label is a sufficient evidence for the validity of the conclusion `A` in the sequent `H, A ⊢ A, G`.

Actually, this description is not entirely accurate as the evidence tells us which assumption was used, but it doesn't tell us which conclusion was proved by it. This issue affects all the rules that have multiple conclusions and can only be resolved if we restrict the sequents to a single conclusion (as in the refinement logic).

For now, we proceed to label the formulas, integrating the information about the evidence into the rules, so the axiom rule becomes:

```hs
Ax   H, a:A ⊢ G, A     evidence for A: a
```

## Left conjunction, `L∧`

The rule `L∧` decomposes a conjunction `A ∧ B` in the assumptions, spliting it into two separate assumptions `A` and `B`, leaving the rest unchanged.

```hs
H, A ∧ B ⊢ G
-------------- L∧
H, A, B ⊢ G
```

For the construction of evidence, let's assume that `x` labels `A ∧ B`, `a` labels `A`, `b` labels `B`, and `g[a,b]` labels the evidence for `H,A,B ⊢ G`, indicating that `A` and `B` may be used in the proof of `G`.

Then by construction, `x` must contain the same information as `(a, b)`, and the evidence for `H, A ∧ B ⊢ G` must indicate that `x` is split into a pair `(a, b)`, whose components are then used to construct the evidence for the goal, `g[a,b]`.

```hs
L∧  H, x:(A ∧ B) ⊢ G        evidence: let (a,b) = x in g[a,b]
      H, a:A, b:B ⊢ G       evidence: H,A,B ⊢ G : g[a,b]

                            evidence for A ∧ B: x
                                         x = (a,b)
                            evidence for A: a
                            evidence for B: b
```

So, the evidence for `H, A, B ⊢ G` is the same as the one for `H, A ∧ B ⊢ G`, modulo the spit...

## Right disjunction, `R∨`

The rule `R∨` decomposes a disjunction `A ∨ B` in the conclusion into two separate conclusions `A` and `B`, leaving the rest unchanged.

```hs
H ⊢, A ∨ B, G
-------------- R∨
H ⊢ A, B, G
```

For the construction of evidence, let us assume that `a` is the evidence for the fact that `A` was proved in `H ⊢ G, A, B`, in which case `inl(a)` denotes the fact that the left disjunct was proven. In case `b` is the evidence for the fact that `B` was proven, the evidence is denoted by `inr(b)`.

Thus, there are two possible ways to construct the evidence for `R∨`:

```hs
R∨    H ⊢ G, A ∨ B      ev: inl(a)
        H ⊢ G, A, B     ev: a

      H ⊢ G, A ∨ B      ev: inr(b)
        H ⊢ G, A, B     ev: b
```

Actually, making evidence construction for `R∨` deterministic is difficult in the presence of multiple conclusions, as the evidence itself cannot tell which of the conclusions was proven.

A fully formal representation of evidence construction for multi-conclusioned Gentzen systems would require a *nondeterministic choice operator*. As we will later show this is due to the fact that multi-conclusioned Gentzen systems, like tableaux and truth tables, represent classical logic, which by nature is nonconstructive.

Fully deterministic construction of evidence for `R∨` is possible only in single-conclusioned Gentzen systems.

## Left disjunction, `L∨`

The rule `L∨` decomposes a disjunction `A ∨ B` in the assumptions and returns two subgoal sequents - one in which we have to use `A` and another in which we have to use `B`, leaving the rest unchanged.

```hs
H, A ∨ B, G
-------------- L∨
H, A ⊢ G
H, B ⊢ G
```

For the construction of evidence, let's assume that `x` is a label for `A ∨ B` in `H, A ∨ B ⊢ G`, that `a` labels `A` in the first, and `b` labels `B` in the second subgoal, and that `g1[a]` and `g2[b]` label the subgoal evidence.

Then by construction, `x` must contain the same information as `a + b`, along with an indicator, which of the two is the case.

Thus the evidence for the main sequent must indicate that `x` is either `inl(a)` or `inr(b)` and that in the first case `a` is used in building `g1[a]` and in the second case `b` is used in building `g2[b]`.

```hs
∨R    H, x:(A ∨ B) ⊢ G    ev: case x of inl(a) → g1[a] | inr(b) → g2[b]
        H, a:A ⊢ G        ev: g1[a]
        H, b:B ⊢ G        ev: g2[b]
```

## Right implication, `R→`

The rule `R→` decomposes an implication `A → B` in the conclusion into the assumption `A` and the conclusion `B`, leaving the rest unchanged.

```hs
H ⊢ A → B, G
------------- R→
H, A ⊢ B, G
```

If `a` labels `A`, and `b[a]` labels the evidence for `B` in `H, A ⊢ G, B`, then this means that we have found a generic way to turn evidence for `A` into evidence for `B`.

In other words, the evidence for `A → B` means that whenever we have the proof for `A`, then we can construct the proof for `B`. This must be a function that takes the evidence `a` for `A` and uses it to compute the evidence `b[a]` for `B`, e.g. `λa.b[a]`

```hs
→R    H ⊢ G, A → B       ev: λa.b[a]
        H, a:A ⊢ B, G    ev: b[a]

                         evidence for B: b[a]
                         evidence for A: a
```

## Left implication, `L→`

The rule `L→` decomposes an implication `A → B` in the assumptions and generates two subgoal sequents - one in which `A` becomes an additional conclusion and one in which we may use `B` to prove the goal.

```hs
H, A → B ⊢ G
------------- L→
H ⊢ G, A
H, B ⊢ G
```

For the construction of evidence let's assume that `f` is a label for `A → B` in `H, A → B ⊢ G`, that `a` is the evidence for `A` in the first subgoal, that `b` is a label for `B` in the second subgoal, and that `g[b]` is the evidence for `G` in that subgoal.

Then building the evidence for `G` from the label `f` for `A → B` in the main sequent is simply a matter of putting the evidence together: `f(a)` will be evidence for `B` and can thus take the place of `b` in `g[b]`, resulting in the evidence `g[f(a)/b]` for `G`.

```hs
L→    H, f:(A → B) ⊢ G      ev: g[f(a)/b]
        H ⊢ G, A            ev: a
        H, b:B ⊢ G          ev: g[b]

                        labels
                            f : A → B               in H, A → B ⊢ G
                            b : B                   in H, B ⊢ G

                        evidence
                          for A     : a            in H ⊢ G, A
                          for G     : g[b]          in H, B ⊢ G

                        new evidence construction
                          for B     : f(a)
                                  b = f(a)
                          for G     : g[b]
                                        ↓ b = f(a)
                                     g[f(a)/b]    in H, B ⊢ G
```

## Right negation, `R¬`

The rule `R¬` is similar to `R→`, because negation, `¬A`, is usually viewed as a method for deriving a contradiction from `A`.

The rule decomposes a negation `¬A` in the conclusion by generating the assumption `A` and removing the conclusion, leaving the rest unchanged.

```hs
H ⊢ G, ¬A
------------- R¬
H, A ⊢ G
```

If `a` is the label for `A` and `g[a]` the evidence for `G` in `H, A ⊢ G`, then the evidence for `¬A` must be a function of the form `λa.g[a]`, indicating that every evidence for `A` can be converted into the evidence for `G`, i.e. the other conclusion (even if there is none, which is equivalent to falsehood).

```hs7
R¬    H ⊢ G, ¬A       ev: λa.g[a]
        H, a:A ⊢ G    ev: g[a]
```

## Left negation, `L¬`

Similarly, the rule `L¬` decomposes a negation `¬A` in the assumptions and generates a subgoal sequent in which `A` becomes an additional conclusion.

For the construction of evidence let's assume that `f` is a label for `¬A` in `H, ¬A ⊢ G` and that `a` is the evidence for `A` in the subgoal.

This means that applying `f` to `a` will result in a contradiction (we have evidence for `A` and evidence for `¬A`, i.e. a method that can derive a contradiction from `A`).

As a consequence any evidence that utilizes this information is evidence for `G`. We denote this evidence by a generic expression `any[f(a)]`.

```hs
L¬   H, f:(¬A) ⊢ G     ev: any[f(a)]
       H ⊢ G, A        ev: a
```

~ ~ ~

The above constructions illustrate why the Gentzen proof rules are correct and that Gentzen systems can prove a formula by providing evidence for its truth.

They are not part of the original proof system but can easily be added to it in order to construct proof terms that can be checked by an independent proof checker.

In proof systems capable of dealing with first-order or higher-order logics, the evidence construction also has an interesting side-effect: it allows the *extraction of programs from proofs* of formulas that state the existence of certain algorithms, and therefore the construction of verified programs through theorem proving.

In a sense, Gentzen systems and the tableau method are dual to each other and we can prove consistency and completeness of Gentzen systems by showing we can translate each sequent proof into a tableau proof and vice versa.
