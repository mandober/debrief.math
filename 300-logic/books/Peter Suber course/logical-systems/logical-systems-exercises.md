---
downloaded:       2022-06-20
page-url:         https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm
article-title:    Peter Suber, Logical Systems, "Exercises"
---
# Peter Suber, Logical Systems, "Exercises"
The Wayback Machine - https://web.archive.org/web/20001117085800/http://www.earlham.edu:80/~peters/courses/logsys/exercise.htm

**Exercises**

[Peter Suber][1], [Philosophy Department][2], [Earlham College][3]

<table><tbody><tr><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day1"><strong>Day 1</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day2"><strong>Day 2</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day3"><strong>Day 3</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day4"><strong>Day 4</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day5"><strong>Day 5</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day6"><strong>Day 6</strong></a></td></tr><tr><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day7"><strong>Day 7</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day8"><strong>Day 8</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day9"><strong>Day 9</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day10"><strong>Day 10</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day11"><strong>Day 11</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day12"><strong>Day 12</strong></a></td></tr><tr><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day13"><strong>Day 13</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day14"><strong>Day 14</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day15"><strong>Day 15</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day16"><strong>Day 16</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day17"><strong>Day 17</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day18"><strong>Day 18</strong></a></td></tr><tr><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day19"><strong>Day 19</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day20"><strong>Day 20</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day21"><strong>Day 21</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day22"><strong>Day 22</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day23"><strong>Day 23</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day24"><strong>Day 24</strong></a></td></tr><tr><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day25"><strong>Day 25</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day26"><strong>Day 26</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day27"><strong>Day 27</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day28"><strong>Day 28</strong></a></td><td><a href="https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day29"><strong>Day 29</strong></a></td><td></td></tr></tbody></table>

Selected exercises are answered in a [separate hand-out][33].

Page and theorem numbers refer to Geoffrey Hunter, *Metalogic*, University of California Press, 1971.

To see what Day 1, Day 2, Day 3, etc. correspond to, see my [syllabus][34].

---

**Day 1**

1.  If we specify a formal system by giving only its language, axioms, and rules, then we are omitting its theorems. Why isn't this inadequate?  
    [[Answer]][35]
2.  Explain why two formal systems with the same set of theorems might not be identical.  
    [[Answer]][36]

**Day 2**

1.  Which of these statements is true?
    1.  "If a method is programmable (written in a programming language and executable on a machine), then it is effective."
    2.  "If a method is effective, then it is programmable."  
        [[Answer]][37]
2.  What's wrong with this statement: "One-to-one correspondence makes no sense applied to infinite sets, for the method of pairing-off can only be effective for a finite number of steps"?
3.  Explain how it is that an infinite set can be put into 1-1 correspondence with one of its own proper subsets. An example is not enough. Why is this kind of 1-1 correspondence not a contradiction?
4.  Prove that a set is infinite iff it can be put into 1-1 correspondence with at least one of its proper subsets.

**Day 3**

1.  What consequences would flow from the decision to permit infinitely long wffs?
2.  Use the reasoning in the proof of metatheorem 14.1 to prove that only countably many things can be said, named, or described, whether in a formal language or in a natural language like English.
3.  Why must enumerations of a set be countable?
    -   Even though Hunter says at the bottom of p. 25 that all sequences are countable by definition, don't answer this exercise by saying "by definition". What considerations would lead us to adopt such a definition?
4.  Can there be an enumerable set that is not effectively enumerable?
    -   This is difficult from where we are now. We will prove an answer on Day 25 (metatheorem 51.9), so you have a while to think about it.
5.  Can there be an effectively enumerable set that is not decidable?
    -   This is also difficult from where we are now. The answer is coming on Day 29 (metatheorem 57.4).

**Day 4**

1.  Is either of the following statements true? If not, why? If one is true, which one and why?
    1.  Because 1 is defined as the first cardinal greater than 0, to say that c = 1 assumes the continuum hypothesis.  
        [[Answer]][38]
    2.  Because 1 is defined as 2 raised to the power of 0, to say that c = 1 assumes the continuum hypothesis.  
        [[Answer]][39]
2.  For a period in his career, Kurt Gödel believed that c = 2. Was this belief compatible with the continuum hypothesis? With the generalized continuum hypothesis?
3.  Study the proof of the uncountability of the real numbers in Hunter's theorem A4. Why can't a similar proof be constructed for the rationals?  
    [[Answer]][40]
4.  In the proof of theorem A4, why must we convert (for example), 0.5000... to 0.4999...?  
    [[Answer]][41]
5.  In his proof of A7, Hunter leaves the proof of an important lemma to the reader, namely, that the set of all strings of 1's and 0's that consist of all 0's after a certain point are enumerable. Can you prove this?
6.  A set of numbers is *dense* if (in their natural order) between any two such numbers, there is a third. The reals are dense because between any two reals numbers there is another real number. Note that if there is a third in this way, then there will also be infinitely many.
    1.  True or false: If a set of numbers is dense, then it is continuous.  
        [[Answer]][42]
    2.  True or false: If a set of numbers is dense and uncountable, then it is continuous.  
        [[Answer]][43]
7.  Explain why transfinite cardinals do not comply with the ordinary rules of arithmetic. For example, 0 + 1 = 0. 0 + 0 = 0. c&#183c = c.
8.  Non-Cantorian set theory is set theory in which Cantor's Continuum Hypothesis (CH) is replaced by its negation. (It might have ~GCH instead of ~CH as an axiom.) Try to imagine life without CH or with ~CH. What sets could be larger than the rationals and smaller than c? What could fall between density and continuity?
9.  Review. Which of the following theorems do we know by the definition of the symbols, and which do we know by proof?
    1.  |**N**| = 0  
        [[Answer]][44]
    2.  |***N**| = c  
        [[Answer]][45]
    3.  |***N**| = 1  
        [[Answer]][46]
    4.  |***N**| = 20  
        [[Answer]][47]
    5.  c = 1  
        [[Answer]][48]
    6.  20 = 1  
        [[Answer]][49]
    7.  2a = a+1  
        [[Answer]][50]
    8.  c = 20  
        [[Answer]][51]
    9.  c > 0  
        [[Answer]][52]
    10.  If |S| = n, then |*S| = 2n (where S is a set)  
        [[Answer]][53]
    11.  2n > n, even if n is infinite  
        [[Answer]][54]
    12.  c = **R** (where **R** is the set of real numbers)  
        [[Answer]][55]

**Day 5**

1.  Why are computable functions limited to total functions?
2.  Prove that all total functions with a finite domain are computable.
3.  No monadic connective (operator) can express all truth-functions. Many triadic connectives can, but all of them are reducible to dyadic connectives. Dyadic connectives can express all truth-functions and cannot be further reduced. Why this privilege or special status for two-ness?  
    [[Answer]][56]
4.  Invent a triadic connective that can express all truth-functions and prove that it can. Then show how it can be reduced to (replaced by) some set of dyadic connectives.
5.  Explain how a finite set of connectives can express an infinite number of truth functions.
6.  If the truth function symbolized by "" were triggered by a button on a calculator, then its "inputs" and "output" would be (respectively):
    1.  propositions, propositions
    2.  propositions, truth-values
    3.  truth-values, propositions
    4.  truth-values, truth-values  
        [[Answer]][57]

**Day 6**

1.  Prove that if "~A" is a wff of P, then "A" is a wff of P.
2.  Prove that if "(A  B)" is a wff of P, then both "A" and "B" are wffs of P.
3.  Prove that there is an effective method for testing formulas of language P for wff-hood.
4.  The grammar of language P has four rules. The fourth is "Nothing else is a wff." What is the significance of this rule?  
    [[Answer]][58]
5.  Must we use a metalanguage to state the alphabet and grammar of a formal language?
6.  Restate the grammatical rules of P as functions.
7.  Why must we define "truth for an interpretation" separately for each connective in the language?
8.  Prove that there is an effective method for testing any wff of P for logical validity.  
    [[Answer]][59]
9.  Why does the logical validity of wffs belong to the formal language, as opposed to the deductive apparatus, of a formal system? Why is it semantic rather than syntactic?

**Day 7**

1.  In proving that any wff of PS (in fact, any truth-function) can be expressed in disjunctive normal form, we implicitly appeal to the premise that distinct truth table columns correspond to distinct truth-functions. (Hence any set of connectives that can determine all truth-table columns can express all truth-functions.) How can we justify this premise?
2.  Explain in informal English how it is possible that a finite set of connectives can express *all* truth-functions, given that the set of truth-functions is infinite.
3.  Write p, ~p, pq, p · q, pq, and pq, using only the connective "|". Then do the same using only "[dagger]".
4.  The great length and complexity of wffs written only with "|" or "[dagger]" are motives to use more than one connective, i.e. to tolerate some redundancy or inelegance. Did anything in recent reading suggest a motive for using fewer rather than more connectives, apart from elegance?  
    [[Answer]][60]
5.  Hunter proved in metatheorem 21.1 that the set of truth-functions {~, } is adequate to express all truth-functions. This set is of special interest because it is the set of truth-functions used by his language P. Using only these truth-functions, express each of the following:
    1.  p · q  
        [[Answer]][61]
    2.  p  q  
        [[Answer]][62]
    3.  p  q  
        [[Answer]][63]
    4.  p  q  
        [[Answer]][64]
    5.  p | q  
        [[Answer]][65]
    6.  p [dagger] q  
        [[Answer]][66]
    7.  ~ (p · q)
    8.  ~ (pq)
6.  A triadic connective takes three arguments. For example, "*" in *(A,B,C) may express (AB)~C. (See Hunter's exercise 1 at p. 51.) Define two triadic connectives which, like the dyadic stroke and dagger functions, are adequate by themselves to express all truth-functions, and prove their adequacy.  
    [[Answer]][67]

**Day 8**

1.  Prove that there is an effective method for testing whether an arbitrary wff of P is an axiom of PS (instantiates one of the axiom schemata). In general, prove that there is an effective test of axiomhood for PS (that the axioms of PS form a decidable set).
2.  Prove that PS has at least 0 axioms, hence at least 0 theorems.
3.  Prove that PS has at most 0 axioms and theorems. (This is based on material in previous reading.)  
    [[Answer]][68]
4.  Hunter's system PS has only one rule of inference, *modus ponens*. But *modus ponens* has the peculiarity that it always shortens wffs (considered as strings of symbols) and never lengthens them. Yet it is possible in PS for theorem *n+1* to be longer than theorem *n*. How can this be?  
    [[Answer]][69]
5.  Prove that wffhood is closed under *modus ponens*, that is, that given wffs as input (premises), MP will produce only wffs as output (conclusions).  
    [[Answer]][70]
    -   Would it be interesting to create a non-standard logic in which wffhood was *not* closed under the rules of inference? Invent some rules of grammar and inference that would be non-standard in this way.
6.  Must we use a metalanguage to state the axioms and rules of inference of a formal system?  
    [[Answer]][71]
7.  Restate *modus ponens* as a function.  
    [[Answer]][72]
    -   Can you generalize your answer and describe an effective method for restating any rule of inference as a function?
8.  Why is it desirable to make proofs finite *by definition*?  
    [[Answer]][73]
9.  Why define proofs to be non-empty sequences of wffs that meet certain conditions?
    1.  Why do we insist on non-emptiness?
    2.  Why do we require a sequence rather than a set?
    3.  Why do we not refer to 'truth' in our definition of 'proof'?
10.  Given Hunter's metatheorem 23.4, (A, AB,  B), and its immediate predecessors, which of the following are also metatheorems? Can you prove that any are, or that any are not?
    1.  A, AB,  B
    2.  AB,  AB
    3.  A, (AB),  B
    4.  A, AB,  B
    5.  A, AB,  B
    6.  A, (AB),  B
    7.  AB,  AB
    8.  AB,  (AB)
    9.  A, (AB),  B
    10.  A, (AB),  B
    11.  (AB)  A  B
    12.  A, AB  B 
11.  Explain why we should generally approve inferences of the type, A  A, and disapprove inferences of the type, A  A.
12.  How does PS avoid the infinite regress in the use of *modus ponens* presented in Lewis Carroll's paradox (in *Gödel, Escher, Bach*, pp. 43-45)?
13.  Before we go further in the book, pause and be creative. How would you even start to prove consistency? completeness? decidability (that there is an effective test of theoremhood)?
    -   These are all coming up soon. The methods of proof are as interesting and important as their conclusions.

**Day 9**

1.  Why is absolute consistency a concept of consistency at all? Why would its presence even come close to satisfying our desire to find consistency?
2.  Is it possible to have simple consistency without absolute consistency or *vice versa*? If not, prove it. If yes, under what conditions? (This is difficult.)
3.  Simple consistency is a fact about what is not provable in a system (namely, there is no wff A such that both A and ~A are provable). From [the hand-out on the isomorphism between formal systems and machines][74] we know that theorems about what is not provable can be translated into theorems about what is not computable. What is the "machine equivalent" of simple consistency?
4.  Prove that in PS a contradiction implies everything. Or more precisely, prove that if PS contains a wff A such that both A and ~A are theorems (i.e. if the system is simply *in*consistent), then every wff of P is a theorem.
5.  What's wrong with this statement: "We cannot prove that an axiom *schema* for PS is true for some I, because it would take infinitely many tests (e.g. truth table tests), one for each possible instantiation of the schema"?
6.  In Post's model-theoretic proof of the consistency of PS, we looked for and found a single interpretation of P that was also a model. Why does *just one* such interpretation suffice to prove consistency? Couldn't *other* interpretations show up an inconsistency, in principle?  
    [[Answer]][75]
7.  In our search for the kind of interpretation sought in the last exercise, why was it important to limit our search to interpretations in which the connectives bear their "usual meanings"?  
    [[Answer]][76]
8.  Let us say that a set of wffs is "basically consistent" iff the conjunction of its members is not a contradiction. Prove that PS is absolutely consistent iff the set of its theorems is basically consistent.
9.  True or false: A system is simply consistent iff the set of its theorems is a p-consistent set.
10.  Explain why every semantic tautology is a syntactic tautology and *vice versa*.
11.  Describe in your own words the problem of circularity in consistency proofs. (Hofstadter talks about this more than Hunter; see *GEB* at pp. 24, 191-92, 229-30.)
12.  How well or badly do our two proofs of the consistency of PS fare in light of the potential circularity of consistency proofs? Do they use any reasoning validated by TFPL?
13.  The last two questions point to a general distinction of great importance. Try to be specific in describing (1) the reasoning validated by TFPL, or exemplified by proofs of theorems *inside* PS, and (2) the reasoning in the metatheory of TFPL, or exemplified in our proofs of metatheorems *about* TFPL.
14.  Explain why "A  A" can denote the consistency of a system, that is, why it implies the simple and absolute consistency of the system.
15.  Describe in your own words the semantic motivation of the concept of consistency.  
    [[Answer]][77]
    -   In what sense does consistency depend on interpretation and in what sense not?

**Day 10**

1.  (A review question to help you with mathematical induction.) In many of our proofs we prove pq by assuming p and deriving q. Why is this valid?  
    [[Answer]][78]
2.  Prove that if system PS has a model, then it is consistent.
3.  What features of PS are used to prove that the deduction theorem holds in it?  
    [[Answer]][79]
    -   Every time a metatheorem is proved for some system, it is proved for all systems that are relevantly similar. Try to be as specific as you can in describing that class of systems for the deduction theorem and for other important metatheorems to come.
4.  Hunter's proof of the deduction theorem uses the method of "conditional proof" (or what Hofstadter called the "fantasy rule"). That is, to prove a proposition of the form, "AB" (namely, the induction step), we assumed A and derived B, and as a result of that derivation felt justified in asserting "AB". But this is to assume that it is valid reasoning to move from AB (assume A, derive B) to (AB). But this is the deduction theorem. Did Hunter use the deduction theorem to prove the deduction theorem? Is his proof valid?
5.  Hunter proves the deduction theorem as a metatheorem (26.1). Hofstadter calls it the "fantasy rule" and gets it into his system of TFPL by making it a rule of inference rather than a metatheorem (see *GEB* at pp. 183-84). What considerations might lead one to get the deduction theorem in the one way or in the other?
    -   What does this show about the interchangeability of metatheorems and rules of inference in general? (See *GEB* at pp. 193-94.)
6.  Can you prove the converse of the deduction theorem, i.e. if (AB), then , AB? We will see a proof in metatheorem 43.2 (Day 19), but it uses only basic TFPL concepts, and does not require mathematical induction. You are in a position to prove it now, if you can just see how.

**Day 11**

1.  Which of the following are true?
    1.  Every model of AB is a model of A.  
        [[Answer]][80]
    2.  Every model of AB is a model of B.  
        [[Answer]][81]
    3.  Every model of A is a model of AB.  
        [[Answer]][82]
    4.  Every model of B is a model of AB.  
        [[Answer]][83]
    5.  Every model of ~A is a model of AB.  
        [[Answer]][84]
    6.  Every model of ~B is a model of AB.  
        [[Answer]][85]
    7.  Every model of {A, AB} is a model of B.  
        [[Answer]][86]
    8.  Every model of {B, AB} is a model of A.  
        [[Answer]][87]
    9.  Every model of {A,B} is a model of AB.  
        [[Answer]][88]
    10.  Every model of {~A,~B} is a model of AB.  
        [[Answer]][89]
2.  Prove that, given AB, every model of A is a model of B. (This is used in the proof of metatheorem 28.4.)
3.  Given ~AB, can you prove that for every I in which A is true for I, B is also true for I?
4.  We know that all tautologies are logically equivalent in TFPL. That is, if A and B are arbitrary tautologies, then AB. In light of this fact:
    1.  Why do we demand that a semantically complete system show that *all* tautologies expressible in P are theorems of the system? Don't we get them all if we get one? Why isn't one enough?  
        [[Answer]][90]
    2.  Why do we demand that language P, which lacks conjunction, contain "the equivalent" of the tautology, ~(p · ~p) ?
5.  A formal system is *decidable* iff there is an effective method for determining whether any given wff is a theorem. Can you prove that PS is decidable?
    -   You have all the tools and information you need as of today. We'll see a proof on Day 14, so you have a few days to think and play.
6.  Describe in your own words the semantic motivation of the concept of completeness.

**Day 12**

1.  Questions about the proof of metatheorem 31.15.
    1.  What if k = 0?  
        [[Answer]][91]
    2.  Luckily k cannot equal 0. Why not?  
        [[Answer]][92]

**Day 13**

1.  Hunter does not prove metatheorem 32.1. Can you?
2.  In light of metatheorem 32.9, will the maximal p-consistent set of theorems of some consistent system always contain *all* the theorems of that system? Why or why not?
3.  Is the converse of metatheorem 32.10 true or false? Can you prove your answer? (The converse would assert that, for any wff A, and maximal p-consistent set , if A, then A.)
4.  Let  be a maximal p-con set of wffs of PS.
    1.  True or false:  could contain all and only the theorems of S.  
        [[Answer]][93]
    2.  True or false:  could contain all and only the non-theorems of S.  
        [[Answer]][94]
5.  Will all the maximal p-consistent sets of wffs from the same system have the same cardinality? Can you prove your answer?
6.  Let us say that a "string" of symbols is any sequence of symbols, regardless of length or wffhood. Prove that the enumeration theorem is true for finite strings and false for denumerable strings.
    -   If the enumeration theorem is modified to refer to enumerability, rather than effective enumerability, then prove that it holds for strings in general, not just for wffs.
7.  In the proof of Lindenbaum's lemma, we are told to add the nth wff of our enumeration of wffs to set n-1, creating set n, iff this addition would not trigger p-inconsistency. But how can we tell whether the nth wff can be added to n-1? Is there an effective method to help us determine whether an addition will trigger p-inconsistency?  
    [[Answer]][95]
8.  Henkin's completeness proof actually concludes that every p-consistent set of PS has a model (metatheorem 31.13). Explain why this is equivalent to proving semantic completeness.
9.  Hunter's metatheorem 32.14 is called the "Strong" completeness theorem of PS: if A, then A. Why is it "stronger" than other completeness theorems?
10.  In the finiteness theorem for language P (metatheorem 32.18) we proved that "" possesses a certain property. We proved that "" possessed the same property in metatheorem 23.7 (Day 8). Why is the finiteness theorem much more interesting and hard to prove for "" than for ""?  
    [[Answer]][96]

**Day 14**

1.  A system has a *kind* of syntactic completeness iff for each wff A, either A or ~A is a theorem. PS does not possess this kind of completeness, and it would not be desirable for PS to do so.
    1.  Why is it undesirable for PS to possess this kind of completeness?
    2.  If a system of TFPL *did* have this kind of completeness, would it be inconsistent?
    3.  For what kinds of systems would it be desirable to possess this kind of completeness? (This is difficult from where we are now.)
2.  A system has another *kind* of syntactic completeness iff no unprovable schema can be added as an axiom schema without creating inconsistency.
    1.  Why is this kind of completeness *syntactic*?
    2.  Why does this kind of completeness refer only to added *unprovables*?
    3.  Why does this kind of completeness refer only to added *schemata*?
    4.  There are two kinds of unprovable schemata that might be added as axiom schemata, one of which creates inconsistency when added and one of which does not. Can you think of them?
3.  Let us say that system S is syntactically incomplete, and that Sch is an unprovable schema that can be added to S as an axiom without making S inconsistent. Can you prove that all the instantiations of Sch will be contingencies?  
    [[Answer]][97]
4.  We give up syntactic completeness, but not semantic completeness, when moving from TFPL to monadic PL. Can you (now) imagine why? When you examine the proof for the syntactic completeness of PS (in 33.1), what in the proof is essentially tied to TFPL or could not be done in monadic PL? If semantic and syntactic completeness are separable for monadic PL, but inseparable for TFPL, then what property of monadic PL can explain this difference from TFPL?
    -   Even if you cannot answer these questions now, think about them as we make the transition to PL on Day 16 and following.
5.  Where in the proof for the syntactic completeness of PS (metatheorem 33.1) are we assured that PS is "full"? Won't adding U to an *incomplete* system still create inconsistency?
6.  To what extent is syntactic completeness equivalent to maximal p-consistency; or to what extent is the assertion of PS's syntactic completeness equivalent to saying that the set of theorems of PS is a maximal p-consistent set? If they are equivalent, then prove that PS is syntactically complete by proving that its theorems form a maximally p-consistent set, hence without presupposing semantic completeness or consistency.
    -   In deciding whether this is possible, ponder Hunter at p. 119 on how a decidable system like PS may have undecidable wffs.
7.  Metatheorem 33.2 shows that we can add the negation of an unprovable wff to a consistent system as an axiom without creating inconsistency. If 33.2 applied only to syntactically incomplete systems, then it would contradict the proof of the syntactic completeness of PS in metatheorem 33.1. Why doesn't this contradiction arise?  
    [[Answer]][98]
8.  If we generalize Hunter's metatheorem 33.2, we might get something like this: Any undecidable wff can be added as an axiom to a consistent system, and the result will be a consistent system. Is this proposition true in general? Is it true for PS? Can you prove it true or false for PS or more generally?
    -   Variation: Any undecidable wff can be added as an axiom *schema* to a consistent system, and the result will be a consistent system. Can you prove or disprove this? (This is more difficult.)
9.  Prove that for some consistent system S, there is no wff A such that both S + A and S + ~A are inconsistent. Or: for every consistent system S, and arbitrary wff A, either A or ~A can consistently be added to the axiom set of S.  
    [[Answer]][99]
10.  Do you think PS has an effective proof procedure? Can you prove your answer? If your answer is yes, can you sketch the method you have in mind?  
    [[Answer]][100]
11.  Can you put your finger on the feature of Hiz's system that allows it to be simply inconsistent and absolutely consistent at the same time?
12.  To prove that PS is decidable, why doesn't it suffice to have A  A? Why do we also need A  A?
13.  Explain why a decidable system need not have an effective proof procedure.
14.  We give up decidability when we move from TFPL and monadic PL to polyadic PL. Why? What in the proof of the decidability of PS (34.1) is essentially tied to TFPL or monadic PL, and cannot be done in polyadic PL?
    -   Even if you can't answer this question now, think about it as we encounter monadic and then polyadic PL.
15.  If a formal system is undecidable, then what can we say about the computer program isomorphic with it?
    -   How does this differ from a formal system with undecidable wffs? What can we say about its isomorphic program?
16.  Explain how a decidable system can have undecidable wffs.
17.  Explain how every wff in an undecidable system can be decidable.

**Day 15**

1.  Let A be an axiom of S and a theorem of S-A. (S-A denotes system S minus axiom A.) Let both S and S-A be consistent.
    1.  Is ~A independent of S?
    2.  Is ~A undecidable in S?
2.  What is the relationship between the independence ("I") and undecidability ("U") of a wff?
    1.  I  U ?
    2.  U  I ?
    3.  I  U ?
    4.  None of the above?
3.  Prove that metatheorem 33.2 (the "non-standardness theorem") holds for independent wffs, not just for undecidable wffs and the negations of theorems.
4.  In proving the independence of an axiom (say, Axiom 1 in metatheorem 36.1) how would one decide on the exotic 3-value definitions of "~" and "" that allow us to discriminate between Axiom 1 and the other axioms?
5.  The strange 'truth table' constructed in the proof of metatheorem 36.1 helps us contrive a strange interpretation I such that axiom-schema #1 is false for I while the other two axiom-schemata of PS are true for I. But this I is so strange that, e.g. the connectives no longer take their standard meanings. How can we be sure, then, that axiom-schema #1 doesn't follow from the other two axiom-schemata in an ordinary or standard interpretation?
6.  Given Hunter's preface to system AB at p. 125, is AB a system in which not everything follows from a contradiction? Can you prove that AB is or is not such a system?

**Day 16**

1.  How is a predicate like and unlike a function?
2.  How is a predicate like and unlike a set?
3.  Why is predicate logic in general not truth-functional?
    -   Can you describe a subset of predicate logic that would be truth-functional?
4.  In a consistent system of predicate logic, can there be any theorems that are open wffs (other than instances of tautological schemata)?
5.  In a consistent system of predicate logic, can there be any theorems that are atomic wffs?  
    [[Answer]][101]
6.  Explain why the members of a set  of PL wffs may be simultaneously satisfiable while  has no model.  
    [[Answer]][102]
7.  How can we use the universal quantifier, negation, and the concept of identity (carried by the traditional symbol "=") to express all the quantities expressed by the natural numbers?  
    [[Answer]][103]

**Day 17**

1.  To interpret Q, we assign truth-values to p', p'', ... , but *not* to wffs whose internal structure is visible, e.g. Fx, Fs, Ffcc... For these, we assign a meaning to the predicate, and an object to the term, and then appeal to an *extra-logical* procedure to determine its truth value (e.g. we hire a private detective). Hence, a structured proposition is not necessarily T or F just from the assignments that interpret the language. Why not just assign truth-values to such propositions?
2.  Why does the concept of satisfaction refer to sequences of members of the domain, and not simply to members or to sets of members of the domain?
3.  Why must we define satisfaction separately for each connective, quantifier, and type of term?
4.  If a set of wffs is simultaneously satisfiable, does it follow that it has a model?
5.  If a wff is not satisfiable, is its negation logically valid? Can you prove that it is or that it is not?
    -   If a wff is logically valid, then is its negation unsatisfiable? Can you prove that it is or that it is not?
6.  The consistency of an arbitrary finite set of PL wffs is an "NP-complete" problem. This means roughly: while there is an effective method to solve the problem, there is no tractable method or method which will solve it in useful time. This is a very important result for the theory of computation. Yet we have methods that are both effective and tractable to prove the simple and absolute consistency of systems with 0 theorems. Can you explain this disparity?
    -   How does the problem of the consistency of an arbitrary set of wffs differ from TFPL (TFPL wffs) to PL (PL wffs)?
7.  How does semantic consequence for language P differ from semantic consequence for language Q? Why?
8.  Why does the definition of semantic consequence, but not syntactic consequence, change from TFPL to PL?
9.  Describe the "border" between TFPL and (monadic) PL. What changes when we cross the border that might explain the metatheoretic results of crossing it?

**Day 18**

1.  Hunter does not provide proofs for any of the metatheorems 40.1 through 40.8. Can you prove any of them?
2.  Questions about the proof of Hunter's metatheorem 40.13:
    1.  Why is it important that vk not be free in A?
    2.  What if A is unsatisfiable?
    3.  Is the quantifier superfluous?
3.  In 40.21, why generalize only from wffs with exactly one free variable? Why use only open wffs, and why use open wffs with exactly one free variable?
4.  Explain how some wffs of PL can be k-valid for every positive integer k and yet not be logically valid.
5.  Which metatheorems in today's reading show that QS has the features we knew from elementary logic as "universal generalization" and "universal instantiation"?

**Day 19**

1.  In proving the consistency of QS (in 42.1), why is the "reduction" of PL to TFPL legitimate? Why does this create no important distortions?
2.  Does the consistency proof for QS (in 42.1) suffer from the circularity problems that beset many consistency proofs?

**Day 20**

1.  At p. 178 Hunter says that adding new constants adds new logical axioms but not new proper axioms. Why is this the case?
2.  Why add new proper axioms instead of proper axiom schemata?
3.  How true is "1 + 2 = 3"? Is it:
    1.  satisfiable
    2.  true for I, or
    3.  logically valid?
4.  In re Hunter's metatheorem 45.1: go back to 26.1 and explain why it applies to AFOTs without change.  
    [[Answer]][104]
5.  In Hunter's metatheorem 45.5, we are told to use K4 (in the form vA  A) on Ac as often as necessary until we get A.
    1.  Spell out "as often as necessary". Do we stop when we have removed all quantifiers from A, leaving A an open wff? If not, when do we stop?
    2.  What would be strange about continuing until A became an open wff?
6.  Questions about Hunter's metatheorem 45.6.
    1.  Why limit 45.6 to closed wffs?
    2.  Does 45.6 presuppose that K is consistent? Have we been given that?
7.  Extend Hunter's metatheorem 45.6 (c and b) by proving that any undecidable closed wff can be added to a consistent FOT without creating inconsistency.
8.  Which kinds of predicate logic will find negation completeness desirable? Which kinds will find it undesirable?
    -   How does the restriction to closed wffs in the definition of negation completeness bear on its desirability?
9.  Why is negation completeness undesirable to all kinds of TFPL?
    -   Why is it desirable to some FOTs but not to QS?
10.  Consider these propositions:
    
    > 1.  S is negation-*in*complete.
    > 2.  S is absolutely consistent.
    > 3.  S has some undecidable wffs.
    
    1.  Is it true that AB ?  
        [[Answer]][105]
    2.  Is it true that AC ?  
        [[Answer]][106]
    3.  Is it true that BC ?  
        [[Answer]][107]
11.  Compare Lindenbaum's lemma for TFPL (Hunter at p. 110) with Lindenbaum's lemma for a FOT (Hunter at p. 177). What similarities justify us giving them the same name?

**Day 21**

1.  What's wrong with this proof?
    -   Let S be a first-order theory.
    -   If S has a model, then S is consistent. (45.8)
    -   Some consistent sets of wffs of first-order theories have no models. (Hunter at p. 186.)
    -   Therefore, consistency doesn't imply modelhood.
    -   Therefore, consistency  modelhood. (The implication works right to left but not left to right.)
    -   But the negation of material equivalence is another way to express exclusive disjunction. (Hunter at p. 69.)
    -   Therefore, if S is consistent, then it must *not* have a model, and if it has a model then it is *inconsistent*.
2.  Why is it legitimate to infer from the closure of a system that its domain is countable?
3.  Prove that a system of arithmetic with an intended uncountable model (hence, with a non-standard countable model as well, under the Löwenheim-Skolem theorem) is not closed.
4.  In Hunter's metatheorem 45.13, is there a limiting case at which K' = K?
5.  Why is metatheorem 45.16 limited to closed wffs?
6.  In light of the Löwenheim-Skolem theorem, in what sense (if any) must we qualify our assertion that the cardinality of the reals is greater than the cardinality of the naturals?
7.  Explain how a consistent set of wffs of an AFOT can fail to have a model.
8.  Explain why a consistent set of closed wffs of an AFOT must have a model and why a consistent set of open wffs need not.
9.  Explain why a consistent set of open wffs of an AFOT might lack a model but must be simultaneously satisfiable in a denumerable domain.
10.  Explain why modelhood and consistency are biconditional in TFPL but not in PL. What was added in PL that created this disparity with TFPL?

**Day 22**

1.  How can QS be semantically but not syntactically complete? That is, how can QS have all logically valid wffs as theorems and yet not be "full"? (The word "ullage" means the empty space in a bottle above the liquid it contains. What is the ullage of QS?)
2.  How can QS be semantically complete but not negation complete?
3.  Why can't we "reduce" PL to TFPL to prove syntactic completeness as we did to prove consistency?
4.  Why is it undesirable for QS to be syntactically complete? Compare this undesirability with the undesirability of negation completeness for QS.
5.  Why is Axiom 9 of QS= limited to closures of [(x=y)(AA')]? 
6.  How does Axiom 9 of QS= make Axiom 8 useful?
7.  In TFPL and with earlier FOT's we proved systems consistent if for an arbitrary wff A, A  A, that is, if all their theorems were logically valid. But QS= has proper axioms; hence not all its theorems are logically valid. Yet in 47.1 we proved that it was consistent. Do we need A  A to prove consistency or not?
8.  Which of the following systems are extensions of which?
    1.  QS of PS?
    2.  QS= of PS?
    3.  QS= of QS?
    4.  QS= of FOT=?
    5.  FOT= of QS=?
9.  Why do we need "normal interpretations" in order to add identity to QS?
10.  Why do we need the new notion of "adequacy" to evaluate systems with identity like QS=?
11.  Why does PL with identity have wffs as theorems that are not logically valid for PL without identity? Why is this desirable?
12.  Describe the "border" between PL with identity and PL without identity. What changes when we cross the border that might explain the metatheoretic results of crossing it?

**Day 23**

1.  What is the motivation for re-defining FOTs here (dropping propositional symbols)?
    -   Or, why not leave propositional symbols in the system and not use them?
2.  To determine isomorphism, why don't we pair-up *variables*? Is the reason related to the reason why variables get no assignment in interpreting language Q?
3.  Hunter omits the proof of metatheorem 48.2. Can you provide one?
4.  Would metatheorem 48.3 be true of FOTs *without* identity (changing "normal models" to "models")? Why or why not?
    -   We can answer this question, but why is it "merely academic"?
5.  Give an example of an English sentence using a numeral as an adjective, and an example of a sentence using a numeral as a noun.
6.  Why is language Q adequate to express numeral adjectives but not numeral nouns?
7.  How can a FOT with identity have models of infinite cardinality and normal models all of whose cardinalities are finite?
8.  Why is the so-called Skolem paradox not really paradoxical?

**Day 24**

1.  Why does language M lack function symbols?
2.  Which of the following systems are extensions of which?
    1.  QSM of QS?
    2.  QS of QSM?
    3.  QSM of QS=?
    4.  QS= of QSM?
3.  Was the consistency proof for QSM (in 50.1, 50.2) circular? Relative?
4.  Why can't we prove A  A as easily in QSM as we can prove its converse, A  A (metatheorem 50.1), in QSM?
5.  Why are syntactic completeness and negation completeness undesirable for QSM?
6.  Why was metatheorem 50.8 limited to closed wffs?
7.  Monadic PL was proved decidable in metatheorem 50.9. We are soon to prove that polyadic PL is *un*decidable. Look over the proof in 50.9 closely. Why does the reasoning in 50.9 apply to monadic but not to polyadic PL?
    -   Even if you cannot answer this question today, think about it as we work through the proof of the undecidability of polyadic PL.
8.  The metatheorem in 50.8, first proved by Paul Bernays and Moses Schönfinkel in 1928, is the most important lemma in the proof (in 50.9) that monadic PL is decidable. Can you describe in informal English the path from 50.8 to 50.9?

**Day 25**

1.  Why is it part of the definition of a computable function that it be a total, not a partial function?
2.  Questions about metatheorem 51.8 and its proof.
    1.  Why doesn't existence of function g show, by a diagonal argument, that the number of computable functions of one argument from natural numbers to natural numbers is uncountable?
    2.  Why use "n" twice in fn(n)? What are the two roles it plays, and why must the *same* variable play both roles?
    3.  If <f0, f1, ...> is not effectively enumerable, then how do we compute g(n) when fn(n) = 0?

**Day 26**

1.  Formal systems of arithmetic are extensions of which of the following?
    1.  QS?
    2.  Respectable system of arithmetic?
    3.  QS=?
    4.  QSM?
2.  Why isn't TFPL made undecidable by the undecidability of its extension, QS? (Or why isn't QS made undecidable by the undecidability of respectable arithmetic?)
3.  Explain why negation completeness is undesirable for TFPL and PL, but desirable for extensions of PL that are formal systems of arithmetic.
4.  Why does Gödel's first incompleteness theorem mean that respectable systems of arithmetic can be consistent or negation complete but not both?
5.  Metatheorem 51.12 says that a respectable, "well-made", negation-complete system is undecidable. Gödel's first incompleteness theorem says that respectable, "well-made" systems are never negation-complete. Hence, the condition in 51.12 is never met, rendering 51.12 a kind of nullity. Yet Hunter's proof of Gödel's theorem (as opposed to Gödel's own proof) relies on 51.12. Is this kosher?
6.  What's wrong with this proof?
    -   Let S be a respectable, well-made system of arithmetic, the sort to which Gödel's first incompleteness theorem applies.
    -   Since S is respectable, S represents every decidable set of natural numbers. [By the definition of respectability.]
    -   Therefore, every 1-wff [wff with exactly one free variable] which is true of all and only the members of some decidable set of natural numbers is a theorem of S. [By the definition of representation.]
    -   G is a 1-wff. [G is the undecidable wff created by Gödel's proof.]
    -   Therefore, if G is true but not provable in S, then G is *not* true of all and only the members of some decidable set of natural numbers.
    -   But G is true of all and only the natural numbers, which is a decidable set.
    -   G says that 0 is not the Gödel-number of the proof of G; 1 is not; 2 is not....
    -   Therefore, no such S can exist. Respectability is unattainable.
7.  Describe the "border" between respectable systems of arithmetic and lesser formal systems of arithmetic. What changes when we cross the border that might explain the metatheoretic consequences of crossing it?

**Day 27**

1.  Why is the statement "every decidable set of natural numbers is recursive" a version of Church's Thesis?
2.  Is the converse of the proposition above, namely, "every recursive set of natural numbers is decidable" as important or interesting? Is it also indemonstrable?
3.  What is the important *difference* between recursive and decidable sets? (It is often overlooked because of their important similarities.)
4.  Now that we know what Church's Thesis is, go back and take another look at Hunter's 51.8 (which was an assumption rather than a metatheorem). Would you consider it a version of Church's Thesis? Why or why not?
5.  Explain how the mu-operator preserves computability when applied to computable functions.
6.  We've already done a little [recursive function theory][108], and you've seen my [hand-out on Turing machines][109]. That should be enough preparation for this question. What is the relation between Gödel's (own) proof of his first incompleteness theorem and Turing's proof that the halting problem is incomputable?
    1.  Compare the use of self-reference in the two proofs.
    2.  Compare the concepts of incompleteness and incomputability.
    3.  Compare the concepts of undecidability (of a wff) and incomputability.
    4.  Compare the concepts of proof and computation.
    5.  Is Turing's proof the "machine equivalent" of Gödel's?
7.  We've defined a "respectable" system of arithmetic as one in which all decidable sets of natural numbers are represented. Assuming Church's thesis, restate the definition of respectability in terms of (1) recursive sets of natural numbers, and (2) recursive functions from natural numbers to natural numbers.
8.  Hunter gives an unnumbered metatheorem at p. 235: if every recursive function is represented in S, then every recursive set is too. Is the converse of this metatheorem true? Can you prove your answer?
9.  What's wrong with the following proof?
    -   Enumerate the general recursive functions thus, <f1, f2, f3, ...>. Call this sequence s.
    -   Using diagonalization we can create a function not in s. Call it g, and define it thus: if fn(n) = 0, then g(n) = 1; if fn(n) 0, then g(n) = 0.
    -   We've seen this kind of diagonalization before; essentially, whatever fn(n) returns, g returns something different for the same input; but n is any natural number; hence g differs from every f in s.
    -   All the f's in s are computable, by construction. (They are all general recursive functions.)
    -   If all the f's are computable, then g is computable. (To compute g(n) we need only compute fn(n).)
    -   Hence, there is a computable function not in s (namely, g).
    -   Hence, there is a computable function that is not general recursive.
    -   Hence, Church's Thesis is false. (One form of Church's Thesis asserts that all computable functions are general recursive.)

**Day 28**

1.  Explain why system H is a finite extension of QS=, but not a finite extension of QS.

**Day 29**

1.  The proof of the undecidability of polyadic PL (Church's Theorem) has been spread over many days. In your own words, reassemble the major premises and state the proof as concisely as you can.
2.  Why can't we "reduce" QS to QSM, or to PS again, in order to prove decidability as we did to prove consistency?
3.  How can monadic PL be decidable and polyadic be undecidable? What is the decisive difference between the two systems that permits this result?
4.  What's wrong with the following proof?
    -   QS is undecidable. (57.2)
    -   QS is a finite extension of PS.
    -   If a finite extension of a system is undecidable, then the original system is undecidable. (Variant of 51.14)
    -   Hence PS is undecidable. (Contradicting 34.1)
5.  All valid arguments (inferences, derivations) of polyadic PL can be proved valid, but there is no effective method for *testing* arbitrary arguments of polyadic PL for validity. Which of the following propositions asserts the correct consequence of this fact for an axiomatic system of PL like QS?
    1.  QS is undecidable.
    2.  QS is not negation complete, that is, has undecidable wffs.
6.  Explain how the asymmetry in metatheorem 57.4 is possible. That is, how can the set of theorems of some system be effectively enumerable, while the set of non-theorems is not? In Hofstadter's language, if there is sufficient information in the "figure" for effective enumeration, why isn't the same information in the "ground"?
7.  Explain how a computer can churn out all and only theorems of polyadic PL (given infinite time) even though polyadic PL is undecidable.
8.  Explain how a computer can churn out all and only theorems of polyadic PL (given infinite time) but not all and only non-theorems.
9.  We know we can program a computer to churn out all and only theorems of PL (given infinite time) but not all and only non-theorems. But...
    1.  Prove that we cannot program a computer to churn out all non-theorems, even in an enumeration that included some theorems, even given infinite time.
    2.  Prove that we *can* program a computer to churn out only non-theorems.
    3.  Prove that we *can* program a computer to churn out infinitely many non-theorems, even infinitely many kinds of non-theorems, given infinite time, but that we cannot program a computer to churn out all non-theorems.
    4.  Can a computer (in infinite time) churn out all and only undecidable wffs? Or merely all undecidable wffs? Can you prove your answer?
    5.  Can a computer (in infinite time) churn out all and only formulas that are non-wffs? Or merely all non-wffs? Can you prove your answer?
10.  Explain how a FOT can be consistent but not omega-consistent.
11.  How did Gödel's first incompleteness theorem prove omega-incompleteness?
12.  What's wrong with the following proof?
    -   Gödel's first incompleteness theorem proves that there is an undecidable wff (in a certain system S), namely the wff "G" that says in effect "I cannot be proved in S".
    -   Hence Gödel's first incompleteness theorem proves that S contains a wff that is not a theorem.
    -   Hence Gödel's first incompleteness theorem proves the absolute consistency of S.
    -   Hence Gödel's first incompleteness theorem contradicts Gödel's second incompleteness theorem.
13.  What's wrong with the following proof?
    -   Gödel's first incompleteness theorem proves that a respectable system of arithmetic is either consistent or complete, but not both.
    -   But Gödel's first incompleteness theorem proves that such systems are incomplete.
    -   Hence such systems are consistent.
    -   Hence Gödel's first incompleteness theorem contradicts Gödel's second incompleteness theorem.
14.  What's wrong with the following proof?
    -   A system is absolutely consistent iff there is a wff of its language that is not a theorem.
    -   Gödel's second incompleteness theorem constructs a wff that is not a theorem, and yet alleges to prove that consistency is not provable.
    -   Hence Gödel's second incompleteness theorem is self-contradictory.
15.  (I've borrowed and adapted this exercise from Howard DeLong.) Evaluate the following objection. "We can trisect an angle, but not if we limit ourselves to a compass and unmarked straight edge. Similarly, we can create a categorical system of the real numbers (overcoming the Löwenheim-Skolem theorem), do away with undecidable wffs in arithmetic (overcoming Gödel's first incompleteness theorem), and have a decision procedure for polyadic predicate logic (overcoming Church's theorem), but not if we limit ourselves to the customary equipment of formal systems of arithmetic studied in this course. Hence, those so-called 'limitative results' are philosophically uninteresting, even mathematically uninteresting. There is no significant sting in them."

---

This file is an electronic hand-out for the course, [Logical Systems][110].

The logic symbols in this file are GIFs. See my [Notes on Logic Notation on the Web][111].

[][112] [Peter Suber][113], [Department of Philosophy][114], [Earlham College][115], Richmond, Indiana, 47374, U.S.A.  
[*peters@earlham.edu*][116]. [Copyright][117] © 1997, Peter Suber.

[1]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/hometoc.htm
[2]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~phil/index.htm
[3]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/
[4]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day1
[5]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day2
[6]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day3
[7]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day4
[8]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day5
[9]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day6
[10]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day7
[11]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day8
[12]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day9
[13]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day10
[14]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day11
[15]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day12
[16]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day13
[17]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day14
[18]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day15
[19]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day16
[20]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day17
[21]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day18
[22]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day19
[23]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day20
[24]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day21
[25]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day22
[26]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day23
[27]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day24
[28]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day25
[29]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day26
[30]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day27
[31]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day28
[32]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/exercise.htm#day29
[33]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm
[34]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/syl-ls.htm
[35]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#1.1
[36]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#1.2
[37]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#2.1
[38]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.1.1
[39]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.1.2
[40]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.3
[41]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.4
[42]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.6.1
[43]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.6.2
[44]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.1
[45]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.2
[46]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.3
[47]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.4
[48]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.5
[49]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.6
[50]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.7
[51]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.8
[52]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.9
[53]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.10
[54]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.11
[55]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#4.9.12
[56]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#5.3
[57]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#5.6
[58]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#6.4
[59]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#6.8
[60]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.4
[61]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.1
[62]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.2
[63]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.3
[64]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.4
[65]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.5
[66]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.5.6
[67]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#7.6
[68]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.3
[69]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.4
[70]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.5
[71]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.6
[72]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.7
[73]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#8.8
[74]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/machines.htm
[75]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#9.6
[76]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#9.7
[77]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#9.15
[78]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#10.1
[79]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#10.3
[80]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.1
[81]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.2
[82]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.3
[83]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.4
[84]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.5
[85]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.6
[86]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.7
[87]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.8
[88]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.9
[89]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.1.10
[90]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#11.4.1
[91]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#12.1.1
[92]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#12.1.2
[93]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#13.4.1
[94]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#13.4.2
[95]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#13.7
[96]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#13.10
[97]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#14.3
[98]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#14.7
[99]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#14.9
[100]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#14.10
[101]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#16.5
[102]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#16.6
[103]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#16.7
[104]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#20.4
[105]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#20.10.1
[106]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#20.10.2
[107]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/answers.htm#20.10.3
[108]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/recursiv.htm
[109]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/turing.htm
[110]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/courses/logsys/lshome.htm
[111]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/writing/logicsym.htm
[112]: https://web.archive.org/web/20001117085800/http://www.eff.org/blueribbon.html
[113]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/hometoc.htm
[114]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~phil/index.htm
[115]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/
[116]: https://web.archive.org/web/20001117085800/mailto:peters@earlham.edu
[117]: https://web.archive.org/web/20001117085800/http://www.earlham.edu/~peters/copyrite.htm
