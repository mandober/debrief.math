# Inference rules

## ‚Ñï

```hs agda
                               n : ‚Ñï
----------------      ----------------------
     0 : ‚Ñï                   S n : ‚Ñï

data ‚Ñï : Set where
  zero : ‚Ñï
  suc  : ‚Ñï ‚Üí ‚Ñï
```

## Predicate EVEN

```hs agda
                             p : even n
----------------      -------------------------
even-z : even 0       even-s p : even (S (S 0))


data even : ‚Ñï ‚Üí Set where
  even-z : even zero
  even-s : {n : ‚Ñï} ‚Üí even n ‚Üí even (suc (suc n))
```

## Simple EQUALITY on ‚Ñï

```hs agda
                               m ‚â£ n
---------------- BC   ------------------------- IC
      0 ‚â£ 0                  S m ‚â£ S n


                n ‚â£ m           n ‚â£ m    m ‚â£ k
------ REFL   ---------- SYM    ---------------- TRANS
n ‚â£ n         S n ‚â£ S n             n ‚â£ k


-- 1Ô∏è‚É£ Equality on ‚Ñï expressed as a Boolean-valued function.
--    Returns Boolean (truth) values.
--    Informational content: 1 bit
_‚â£_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
0     ‚â£ 0     = true
0     ‚â£ suc y = false
suc x ‚â£ 0     = false
suc x ‚â£ suc y = x ‚â£ y


-- 2Ô∏è‚É£ Equality on ‚Ñï expressed by returning the type ‚ä§
--    if the numbers are equal or the type ‚ä• otherwise.
--    Returns types, not values! üî∫
--    Informational content: 1 bit
_‚â£·µó_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Set
0     ‚â£·µó 0     = ‚ä§
0     ‚â£·µó suc y = ‚ä•
suc x ‚â£·µó 0     = ‚ä•
suc x ‚â£·µó suc y = x ‚â£·µó y
```

## EQUALITY predicate on ‚Ñï

```hs agda
                            p : n ‚â°·¥∫ m
----------------      ----------------------
z‚â°·¥∫z : 0 ‚â°·¥∫ 0          s‚â°·¥∫s p : S n ‚â°·¥∫ S m


                        p : n ‚â°·¥∫ m        p : n ‚â°·¥∫ m    q : m ‚â°·¥∫ k
----------------    -----------------     ------------------------
‚â°·¥∫-refl : n ‚â°·¥∫ n    ‚â°·¥∫-sym p : m ‚â°·¥∫ n      ‚â°·¥∫-trans p q : n ‚â°·¥∫ k


-- 3Ô∏è‚É£ Equality (observational equality) on ‚Ñï as a specialization
--    of the general equality predicate, i.e. of the Identity type.
data _‚â°·¥∫_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Set where
  z‚â°·¥∫z :                          0 ‚â°·¥∫ 0
  s‚â°·¥∫s : {n m : ‚Ñï} ‚Üí n ‚â°·¥∫ m ‚Üí suc n ‚â°·¥∫ suc m


-- 4Ô∏è‚É£ Identity type (for reference)
data _‚â°_ {A : Set} (x : A) : A ‚Üí Set where
  refl : x ‚â° x
```

Identity type dispenses with the two inference rules about equality; in fact, this set of two inference rule express the equality only for the ‚Ñï type, not for any type in general. An alternative set of inference rules about the equality for the ‚Ñï type contains just a single rule that states that any number `n` is equal to itself, `n = n`, along with the assumption that `n : ‚Ñï`.

```hs
n : ‚Ñï
-----
n ‚â° n
```

It is this rule that the Identity type translates, in fact, the generalization of this rule so as to refer to any term of any type. So, first we need to make assumptions that `A` is a type, and that variables `x` and `y` denote two terms of the type `A`; then, we conclude that `x` and `y` are actually equal, i.e. they are the same term, `x` (or `y`).

Judgement that two values (of some type) are equal:

```hs
A : Type   x y : A
-------------------
      x ‚â° y

Œì ‚ä¢ A Type   Œì ‚ä¢ x y : A
-------------------------
     Œì ‚ä¢ x ‚â° y


Œì ‚ä¢ a ‚â° b : A


Œì ‚ä¢ a ‚â°·¥Ä b


-- Identity type
data _‚â°_ {A : Set} (x : A) : A ‚Üí Set where
  refl : x ‚â° x
```

We can compare the equality on ‚Ñï obtained through the use of the `‚â°` (identity type as a generic predicate) and the use of `‚â°·¥∫` (equality predicate specialized to ‚Ñï):

```agda hs
1‚â°·¥∫1 : 1 ‚â°·¥∫ 1
1‚â°·¥∫1 = s‚â°·¥∫s z‚â°·¥∫z

2‚â°·¥∫2 : 2 ‚â°·¥∫ 2
2‚â°·¥∫2 = s‚â°·¥∫s (s‚â°·¥∫s z‚â°·¥∫z)

-- vs

1‚â°1 : 1 ‚â° 1
1‚â°1 = refl

2‚â°2 : 2 ‚â° 2
2‚â°2 = refl
```

‚ú® This shows that the proofs like `1‚â°·¥∫1` and `2‚â°·¥∫2` obtained with `‚â°·¥∫` (equality predicate specialized to ‚Ñï) are much more useful than the proofs like `1‚â°1` and `2‚â°2`, obtained with `‚â°` (aka identity type as a generic predicate).

The proof like `1‚â°·¥∫1` has richer structure and contains more information; it actually contains the exact sequence of rules used to obtain the proof, as opposed to the corresponding proof `1‚â°1` which just contains the term `refl`, asdoes any other proof of equality of naturals using `‚â°` (i.e. they all contain just a single term, `refl`).

Although this seemed initially surprising, come to think about it - it really should be. After all, it is quite logical that a predicate specialized to `‚Ñï` knows more about `‚Ñï` than a generic predicate.



## LESS THAN OR EQUAL relation on ‚Ñï

```hs agda
                           p : n ‚â§ m
----------------      ----------------------
z‚â§s : 0 ‚â§ S m          s‚â§s p : S n ‚â§ S m
```

## Predicate "is not 0"

```hs agda
                          p : n ‚â†0
----------------      ----------------------
s‚â†0 : suc n ‚â†0            s‚â§s p : suc n ‚â†0


data _‚â†0 : ‚Ñï ‚Üí Set where
  suc‚â†0 : {n : ‚Ñï} ‚Üí suc n ‚â†0
```

## Addition

Inference rules for judgments about equality.

```hs agda

    n : ‚Ñï                  m + n  =  p
----------------      ----------------------
0 + n  =  n              S m + n  =  S p


-- definition of addition in Agda
_+_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
0       + n = n
(suc m) + n = suc (m + n)
```

It seems that the inference rule concerning operations correspond to computation rules (as opposed to corresponding to intro or elim rules). Instead of naming the rules (e.g. `z‚â§s : 0 ‚â§ suc n`), they state which equations hold (they have `=` instad of `:`).

```hs agda

    n : ‚Ñï                  p  =  m + n
---------------      ----------------------
  n = 0 + n              S p  =  S m + n

    n : ‚Ñï                  p  :  n ‚â§ m
---------------      ----------------------
z‚â§s : 0 ‚â§ S n          s‚â§s p  :  S n ‚â§ S m
```
