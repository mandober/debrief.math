# 1.2 Function types

HoTT Book > I Foundations > 1.1. Type theory > 1.2 Function types

## 1.2 Function types

Given types `A` and `B`, we can construct the type `A → B` of functions with domain `A` and codomain `B`.

Given a function `f : A → B` and an element of the domain `a : A`, we can **apply** the function to obtain an element of the codomain `B`, denoted `f a`, and called the **value** of `f` at `a`.

>Unlike in set theory, functions are not defined as *functional relations*; rather, they are a *primitive concept* in type theory.


We explain the **function type** by prescribing
- what we can do with functions (elim rules)
- how to construct them (intro rules)
- what equalities they induce (computation rules)


We construct the elements of `A → B` either by direct definition or using lambda abstraction.

### Function by name

Introducing a function by a definition means we introduce a function by a name, e.g. `f`, and saying that we define `f : A → B` by giving an equation

    f x :≡ Φ

where `x` is a variable and `Φ` is an expression which may use `x`. To be valid, we need to check that `Φ : B`, assuming `x : A`.

We compute `f(a)` by replacing the variable `x` in `Φ` with `a`. Consider the function `f : ℕ → ℕ`, defined by `f(x) :≡ x + x`; then `f(2)` is judgmentally equal to `2 + 2`, i.e. to 4.

### Function as a lambda

If we don't want to introduce a name for the function, we use **abstraction**: given an expression `Φ` of type `B`, which may use `x : A`, write `λ(x:A).Φ`. Thus, we have:

    (λ(x:A).Φ) : A → B

For the example in the previous paragraph, we have the typing judgment

    (λ(x : ℕ). x + x) : ℕ → ℕ


As another example, for any types `A` and `B` and any element `y : B`, there is a *constant function* `(λ(x : A). y) : A → B`.

Generally we omit the type of the var `x` in a λ-abstraction writing `λx.Φ`, since the typing `x : A` is inferable from the judgment that function `λx.Φ` has type `A → B`.

By convention, the "scope" of the variable binding (λx. …") is the entire rest of the expression, unless delimited with parentheses. Thus, for instance, `λx. x + x` should be parsed as `λx. (x + x)`, not as "(λx. x) + x" (which would, in this case, be ill-typed anyway).

Another equivalent notation is

    (x ⟼ Φ) : A → B

We may also sometimes use a dash (-) in the expression `Φ` in place of a variable, to denote an implicit λ-abstraction. For instance, `g(x, -)` is another way to write `λy. g(x, y)`.

Now a λ-abstraction is a function, so we can apply it to an argument `a : A`. We then have the following **computation rule**, which is a definitional equality (this equality is often referred to as β-conversion or β-reduction):

    (λx.Φ)(a) ≡ Φ′

where `Φ′` is exp `Φ` in which all occurrences of `x` have been replaced by `a`.

Note that from any function `f : A → B`, we can construct a lambda abstraction `λx. f (x)`. Since this is by definition "the function that applies `f` to its argument" we consider it to be definitionally equal to `f` (this equality is often referred to as η-conversion or η-expansion):

    f ≡ λx.f x

This (η) equality is the **uniqueness principle for function types** because it shows that `f` is uniquely determined by its values (so, extensionality).


The introduction of the function by definition with explicit parameters can be reduced to a simple definition that uses λ-abstraction; that is, we can read a definition of `f : A → B` by 

    f(x) :≡ Φ

as

    f :≡ λx.Φ


Pay atention not to capture vars when substituting:

When doing calculations involving variables, we have to be careful when replacing a variable with an expression that also involves variables, because we want to preserve the binding structure of expressions. By the **binding structure** we mean the invisible link generated by binders such as `λ`, `Π` and `Σ` between the place where the variable is introduced and where it is used. Naive substitution would destroy the binding structure, allowing us to perform calculations which are semantically unsound.

Judgmental equality (α-conversion): `λz+z` ≡ `λy.y` 

Polyadic functions may be defined using the Cartesian product: function with params `A` and `B` and result in `C` has the type `f : A × B → C`. Polyadic functions may also be defined using **currying**.

Our notation for definitions with explicit parameters extends to this situation: we can define a named function `f : A → B → C` by giving an equation

    f(x,y) :≡ Φ

where `Φ : C` assuming `x : A` and `y : B`. Using λ-abstraction this corresponds to

    f :≡ λx.λy.Φ

which may also be written as

    f :≡ x ⟼ y ⟼ Φ

We can also implicitly abstract over multiple variables by writing multiple blanks, e.g. `g(-, -)` means `λx.λy.g(x, y)`. Currying a function of three or more arguments is a straightforward extension of what we have just described.
