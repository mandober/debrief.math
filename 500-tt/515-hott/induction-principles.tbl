# Induction principles

Data type can be
- defined as a GADT (using `data`)
- defined as a record (only if single data ctor, free `Î·`-rule)
- non-universe polymorphic, `Ï„ : Type`
- universe polymorphic, `Ï„ : ğ“¤`, `Ï„ : {ğ’¿ : Level} â†’ A â†’ ğ“¤ ğ’¿`
- dependent elimination rule
- non-dependent elimination rule

Data types with induction principles
- ğŸ˜ type
- ğŸ™ type
- ğ”¹ type
- â„• type
- List types
- Sigma types, `Î£`
- Identity types, `â‰¡`


<!-- TOC -->

- [0-type](#0-type)
- [1-type](#1-type)
- [2-type](#2-type)
- [Naturals](#naturals)
- [Ordinal type](#ordinal-type)
- [List](#list)
- [Pair](#pair)
- [Sigma type](#sigma-type)
- [Identity type](#identity-type)

<!-- /TOC -->

## 0-type

```agda hs
-- ğŸ˜-intro
data ğŸ˜ : Type where

ğŸ˜-elim : {R : ğŸ˜ â†’ Type}
       ----------------
       â†’ (x : ğŸ˜) â†’ R x
ğŸ˜-elim ()


-- ğŸ˜-intro (universe polymorphic)
data ğŸ˜ : ğ“¤ where

ğŸ˜-elim : {R : ğŸ˜ â†’ ğ“¤}
       ----------------
       â†’ (x : ğŸ˜) â†’ R x
ğŸ˜-elim ()
```

## 1-type

```agda hs
-- | 1-type as a GADT
data ğŸ™ : Type where
  â˜… : ğŸ™

ğŸ™-elim : {R : ğŸ™ â†’ Type}
       â†’ R â˜…
       ----------------
       â†’ (x : ğŸ™) â†’ R x
ğŸ™-elim a â˜… = a

-- ----------------------------------------------------------------------------
-- | 1-type as a record
record ğŸ™ : Type where
  constructor â˜…

-- | ğŸ™-elim dependent
ğŸ™-elim : {A : ğŸ™ â†’ Type}
       â†’ A â˜…
       ----------------
       â†’ (x : ğŸ™) â†’ A x
ğŸ™-elim a â˜… = a

-- ----------------------------------------------------------------------------
-- | ğŸ™-elim non-dependent
ğŸ™-nondep-elim : {A : Type}
              ------------
              â†’ A â†’ ğŸ™ â†’ A
ğŸ™-nondep-elim {A} = ğŸ™-elim {Î» _ â†’ A}



-- ----------------------------------------------------------------------------
-- | 1-type GADT universe polymorphic
data ğŸ™ : ğ“¤ where
  â˜… : ğŸ™

-- | 1-type as a record universe polymorphic
record ğŸ™ : ğ“¤ where
  constructor â˜…
```


## 2-type

```agda hs
data ğŸš : Type where
  tt ff : ğŸš

ğŸš-elim : {R : ğŸš â†’ Type}
       â†’ R tt
       â†’ R ff
       ---------------
       â†’ (b : ğŸš) â†’ R b
ğŸš-elim f g tt = f
ğŸš-elim f g ff = g
```

## Naturals

```agda hs
data â„• : Set where
  zero : â„•
  succ : â„• â†’ â„•

â„•-elim : {R : â„• â†’ Type}
       â†’                  R zero
       â†’ ((k : â„•) â†’ R k â†’ R (succ k))
       ------------------------------
       â†’ (n : â„•) â†’ R n
â„•-elim f g zero     = f
â„•-elim f g (succ n) = g n (â„•-elim f g n)
```

## Ordinal type

```agda hs
-- Brouwer ordinals
data Ord : Set where
  zeroOrd : Ord
  sucOrd  : Ord â†’ Ord
  limOrd  : (Nat â†’ Ord) â†’ Ord

ord-elim : {P : Ord â†’ Set}
         â†’                                             P zeroOrd
         â†’ ((o : Ord)                    â†’ P o      â†’  P (sucOrd o))
         â†’ ((h : Nat â†’ Ord) â†’ ((n : Nat) â†’ P (h n)) â†’  P (limOrd h))
         -----------------------------------------------------------
         â†’ (o : Ord) â†’ P o
ord-elim z f g zeroOrd    = z
ord-elim z f g (sucOrd o) = f o (ord-elim z f g o)
ord-elim {P} z f g (limOrd h) = g h (\n â†’ ord-elim z f g (h n))
```

## List

```agda hs
data List (A : Type) : Type where
  []   : List A
  _::_ : A â†’ List A â†’ List A

List-elim : {X : Type
            {R : List X â†’ Type}
          â†’                                 R []
          â†’ ((x : X) (xs : List X) â†’ R xs â†’ R (x :: xs))
          -----------------------------------------------
          â†’ (xs : List X) â†’ R xs
List-elim f g []        = f
List-elim f g (x :: xs) = g x xs (List-elim f g xs)
```

## Pair

```agda hs
record Pair (A B : Type) : Type where
  constructor
    _â¨¯_
  field
    fst : A
    snd : B

Pair-elim : {A B : Type}
            {P : Pair A B â†’ Type}
          â†’ ((x : A) (y : B) â†’ P (x â¨¯ y))
          ------------------------------------
          â†’ (p : Pair A B) â†’ P p
Pair-elim f (x â¨¯ y) = f x y
```

## Sigma type

```agda hs
-- | Î£ as GADT
data Î£ {A : Type} (B : A â†’ Type) : Type where
  _,_ : (x : A) (y : B x) â†’ Î£ {A} B

-- | projection 1
Ï€â‚ : {A : Type} {B : A â†’ Type} â†’ Î£ B â†’ A
Ï€â‚ (x , y) = x

-- | projection 2
Ï€â‚‚ : {A : Type} {B : A â†’ Type} â†’ (z : Î£ B) â†’ B (Ï€â‚ z)
Ï€â‚‚ (x , y) = y

-- | Î£ recursor is the same no matter how Î£ is defined
Î£-elim : {A : Type }
         {B : A â†’ Type}
         {R : (Î£ {A} (Î» x â†’ B x)) â†’ Type}  -- or: {R : (Î£ x â¦‚ A , B x) â†’ Type}
       â†’ ((x : A) (y : B x) â†’ R (x , y))
         ---------------------------------
       â†’ (z : (Î£ {A} (Î» x â†’ B x)))         -- or: (z : Î£ x â¦‚ A , B x)
       â†’ R z
Î£-elim f (x , y) = f x y


-- | Î£ as a record
record Î£ {A : Type } (B : A â†’ Type) : Type where
  constructor _,_
  field
    Ï€â‚ : A
    Ï€â‚‚ : B Ï€â‚

-- | Î£ syntax sugar helper
Sigma : (A : Type) (B : A â†’ Type) â†’ Type
Sigma A B = Î£ {A} B

-- | Î£ syntax sugar
syntax Sigma A (Î» x â†’ b) = Î£ x â¦‚ A , b
```

## Identity type

```agda hs
-- | Identity (as GADT, no sure if record definition possible?)
data _â‰¡_ {A : Type} : A â†’ A â†’ Type where
  refl : {a : A} â†’ a â‰¡ a

-- | Identity elimination
â‰¡-elim : {X : Type}
         {A : (x : X) â†’ (y : X) â†’ x â‰¡ y â†’ Type}
        â†’ ((x : X) â†’ A x x (refl x))
        ----------------------------------------
        â†’ (x : X)
        â†’ (y : X)
        â†’ (p : x â‰¡ y)
        â†’ A x y p
â‰¡-elim f x x (refl x) = f x


-- ----------------------------------------------------------------------------
-- | Identity - universe polymorphic
data _â‰¡_ {n : Level} {A : ğ“¤ n} : A â†’ A â†’ ğ“¤ n where
  refl : (a : A) â†’ a â‰¡ a

-- | Identity (universe polymorphic) dependent elimination
â‰¡-elim : {i : Level}
         {A : ğ“¤ i}
         {P : ((x : A) â†’ (y : A) â†’ x â‰¡ y â†’ ğ“¤ i)}
       â†’ ((x : A) â†’ P x x (refl x))
         -------------------------------------
       â†’ (x y : A)
       â†’ (p : x â‰¡ y)
       â†’ P x y p
â‰¡-elim f x .x (refl .x) = f x
```
