# Regex

## Regex

## Regex to NFA

## Regex to NFA with GNFA method

## NFA to regex - the "general" general method

## Brzozowski Derivatives

https://www.youtube.com/watch?v=s9EPoy9r-ok

We introduce the idea of a *"derivative" of a regular expression*. The idea is to "divide" the string outta the strings generated by the regex.

We give a definition of what a *derivative of a language* is, and prove that the properties hold when considering a regex.

The purpose of these derivatives, called *Brzozowski Derivatives*, is that we can determine whether or not a regex can generate a string by repeatedly applying a derivative to each character of the string.

## Derivative of a language

Let u ∈ Σ⃰ and L any language. 
A derivative with respect to `u` 

U⁻¹L = { v | uv ∈ L }

in other words, take every string `v` in `L`, and if the string `u` is in front of `v`, strip `u`.

For example, 
if `L = {01, 10, 11}` 
and u = 1 
then `1⁻¹L` = {0, 1}

Note that the string "01" is skipped from derivation as it doesn't start with 1, so it also doesn't appear in the derived language.

## Derivative of a regex

A regular expression:
- base cases
  - RE = ε
  - RE = ∅
  - RE = x
- inductive cases
  - RE = R₁ ∪ R₂
  - RE = R₁R₂
  - RE = R⃰

Let `b` be a single char. 

`b⁻¹R` for each of the 6 cases of a regex:
- RE = ε        ⇒ b⁻¹R = ∅
- RE = ∅        ⇒ b⁻¹R = ∅
- RE = x        ⇒ b⁻¹R = ∅ if a ≠ b else ε
- RE = R₁ ∪ R₂  ⇒ b⁻¹(R₁ ∪ R₂) = `b⁻¹(R₁) ∪ b⁻¹(R₂)`
- RE = R₁∘ R₂    ⇒ b⁻¹(R₁∘ R₂)   = `b⁻¹(R₁) ∘ R₂ ∪ 𝟙 {ε ∈ R₁} ∘ b⁻¹(R₂)`
- RE = R⃰       ⇒ b⁻¹(R⃰)      = `b⁻¹(R) ∘ R⃰`

R⃰ = {ε} ∪ R ∪ RR ∪ RRR ∪ R⁴ ∪ R⁵ ∪ …

The `𝟙` in `𝟙 {ε ∈ R₁} ∘ b⁻¹(R₂)` is *the indicator function*:   
`𝟙{x}` is `ε` (empty string) if `x` is true; else `∅` (empty set).    

So, if `ε ∈ R₁` then we can take the derivative of `R₂`, i.e. do `b⁻¹(R₂)`; otherwise, if `ε ∉ R₁`, then we cannot take the derivative of `R₂` (early exit). That is, the expression `{ε ∈ R₁}` evaluates to ∅, and the concat (∘) of ∅ with anything is ∅; in this case, `∅ ∘ b⁻¹(R₂) = ∅`.

`𝟙 {ε ∈ R₁} ∘ b⁻¹(R₂)`
- `ε ∈ R₁` is true,  then `ε ∘ b⁻¹(R₂) = b⁻¹(R₂)`
- `ε ∈ R₁` is false, then `∅ ∘ b⁻¹(R₂) = ∅`

The indicator function plays the role of a Boolean conditional with an early exit.

The *Brzozowski derivation* allows us to start with a regex and proceed one character at a time, reducing the regex over and over again. This shows whether a string can be made with that regex. We take a string as input and proceed with one character at a time, trying to take derivatives. If, at some point, we cannot proceed further, and we get the the empty set, that tells us that the string can't be made by that regex. But if we can take derivatives all the way through, successfully taking the derivative every time, then we can show that the string can be made by the regex.
