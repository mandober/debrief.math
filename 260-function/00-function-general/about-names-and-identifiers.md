# About names and identifiers

Mathematical objects have *informal names*, that is, the colloquial names we use to talk about them.

Mathematical objects also have *formal names*, that is, idetifiers (also called just *names*) that are used in the mathematical "code", i.e. in equations and formulas and such.

Most mathematical objects have informal names and we always try to invent more if needed, which is always better then using contraptions like "that part of the expression below the horizontal line". The problem is that people have to agree on their use, so it becomes "standardized". Unfortunatelly, this is not always a smooth process so many terms are left ambiguous or *underdefined*.

Aside: The definition of a mathematical object is a separate aaspect from the name of that object, but we still need a name to know what the hell the definition refers to, don't we? Math has an interesting compromise when it comes to *incomplete definitions*: when a definition encounters opposition or any other problems that prevent it to be stated in completion, or even if it is deliberatley left incomplete. Then the part that is agreed upon (cemented) is preserved and used as what could be called an *underdefinition* (always used as an adjective, "underdefined"). To complete the definition, the author needs to provide the missing ingerediants.

*Informal names* are loose and arbitrary but it's still paramount that we all agree on them, otherwise we woulnd't know what the fuck are we taling about. Informal names of mathematical objects are similarly trated like nouns: there are proper nouns that refer to a single object, and then there are collective nouns that refer to the entire set. In math, a collective noun would be "functions", and a proper noun could be "the Ackermann function" (even though there is a single particular function authored by Ackermann, there is also a number of related versions of that function authored by him or others, which implies there is hardly "the" Ackermann function, but them's the apples). Another general term is "series", while the term "the Taylor series" maybe suggest it refers to a single particular series, it doesn't. It also refers to a whole set of series that share some common attributes. It seems having an informal proper name for exactly one particular thing is a rare occurrency in mathematics. As soon as someone comes up with something, like a function, the author itself or his contemporaries or even future generations are bound to tweak it, thereby breaking its uniqueness. Some objects do manage to preserve the bijection between an object and its name, e.g. Euler's number, `e`, or the constant `Ï€` (althoug they may have more then one informal name really).

Anyway, the point is that there is no point; it is just a rant about names. Now, with *formal names*, the picture is different. A formal name here is taken to mean an *identifier* as it is used in the mathematical text or "code", i.e. in equations and formulas. 

Objects that we name can be referred to later, as opposed to an army of unnamed, ananymous objects (e.g. intermediary expressions). A formal language prescribes which kinds of objects may be named. For example, any programming language allows naming simple, unitary objects, mostly bound by variables. That is, we can't name a number 5, but we can assign 5 to a variable named `x`, which indirectly serves the same purpose. We can assign many things to a variable, like expressions and particularly expressions of sepcial form that become functions. 

Some programming languages have formal names for even for compund objects; for example, all lists may be referred by `List`, or all functions may be referred by a name like `Callable` or `Fn`, or similar, even though these are compound incomplete (unsaturated) objects. Some PLs support naming and renaming types even.

These features are not really necessary in math, so we don't see them. Math does have *identifiers* (aka *names*) that mostly variables but also functions can take on. Even though math is generally not interpreted by a compiler or interpreter but practiced on "paper", it still must respect some rules abnout identifiers. Namely, when we evaluate some expression, all non-constants, that is, all names, must be resolved. For example, evaluating an application of a function `f` to an argument 5 depends on how the function is defined (and it stype). If the definition of `f` is simple like `f(x) = x + 2`, then evaluating the expression `f(5)` is easy: f(5) = 5 + 2 = 7. But how about `f(x) = ax+2`? We must know what the unknown name `a` stands for. In any PL, the evaluation of this function call expression would be suspended when the identifier `a` is encountered in order to resolve it. The resolution is done by consulating the symbols table that the interpreter constructed when the source code what parsed (or maybe later, as a result of some evaluation). The goal is to find out what the `a` refers to, what is its value. That information is recoded in the symbols table which registeres the value of `a` along with additional information, like its type. If the info about `a` cannot be found for any reason, the evaluation stops, reporting an error along the lines: "invalid reference".

Sure, math is much more flexible, and in fact, `a` need not be defined anywhere, but we must at least know what `a` represents. Is it another variable, or just a constant playing the role of an arbitrary coeffiecient? Without knowing the exact value of `a` we cannot evaluate the enclosing expression down to a (constant) results, but we get the idea about what it is about; perhaps, the actual concrete value of `a` is not at all important, it is just some constant so why bother inventing one.
