# Function signature

https://en.wikipedia.org/wiki/Type_signature
https://en.wikipedia.org/wiki/Function_signature

In PLs with a static type system, a **type signature** specifies the type of language items (values, expressions, type and data constructors, functions, type classes, etc.), but most of the time it refers to the specification of types of a function. When the type is specified for an expression, especially for a subexpression, it is usually called **type annotation**.

A function's signature may be understood as a set of items that unambiguously identify a function. You would think that a function's name is sufficient for that purpose, however it is not in case of polymorphic functions and overloading.


, number, and the order of function's input values (arguments).

the type of function's input values, and the type of its outputs.

A type signature specifies the number, types, and the order of the arguments that a function expects.

A type signature is typically used during overload resolution for choosing the correct definition of a function to be called among many overloaded forms.


Haskell is the pinnacle of an effort to develop a programming language driven by a serious academic effort and their desire to integrate all the long-standing knowledge, along with the recent discoveries, primarily in the PLT (programming language theory) but also in the related fields such as theoretical CS, mathematics, logic, type theory, category theory, etc. In fewer words, Haskell inherits the academic support and the syntaxtical influence from the respected languages that came before, meaning that we might as well just consult Haskell's approach to typing, knowing that it was done right.

In computer science, a **type signature** usually refers to a user-specified, standalone, type expression that describes a function's type, while **type annotations** usually mean user-specified types that are inlined into expressions so as to refer to only some part of it.

In a statically-typed PLs, long before the compilation starts, all the language entities must already be assigned the correct type, whether by the programmer (and verified by the type-checker) or automatically inferred by the type-checker.
