# Free monoids

Categories correspond to strongly typed languages, monoids to untyped languages.

That is because in a monoid you can compose any two arrows, just as in an untyped language you can compose any two functions (although you may end up with a runtime error when you execute your program).

## Monoids

A *monoid* may be described as a category with a single object, where all logic is encoded in the rules of morphism composition.


This categorical model is fully equivalent to the more traditional set- theoretical definition of a monoid, where we "multiply" two elements of a set to get the third element.

This process of "multiplication" can be further dissected into
- first forming a pair of elements
- and then identifying this pair with an existing element, their "product".

```
(a, b) ⟼ ab

(2, 3) ⟼ 6

assuming

  [2] ⟼ 2
  [3] ⟼ 3

  (2,3) ~ [2] ++ [3] = [2,3] ⟼
  (2,3) ~  2  *   3  = 6
  so
  [2,3] ⟼ 6
```

>What happens when we forgo the second part of multiplication, i.e. the identification of pairs with existing elements?

We can, for instance, start with an arbitrary set, form all possible pairs of elements, and call them new elements. Then we pair these new elements with all possible elements, and so on.

This is a chain reaction - we keep adding new elements forever. The result, an infinite set, will be almost a monoid. Almost because a monoid also needs a *unit element* and *the law of associativity*. No problem, we can add a special unit element and identify some of the pairs - just enough to support the unit and associativity laws.

## Example

An example of this would be to start with a set of two elements, `{a, b}`. These elements are the *generators of the free monoid*.

First of all, we add a special element `ϵ` to serve as the unit. Next we add all the pairs of elements and call them "products".
- the product of `a` and `b` is the pair `(a, b)`
- the product of `b` and `a` is the pair `(b, a)` (no commutativity)
- the product of `a` and `a` is the pair `(a, a)`
- the product of `b` and `b` is the pair `(b, b)`

The products involving `ϵ`, e.g. the product of `a` and `ϵ`, the pair `(a, ϵ)`, is identified with just `a` due to the law of unit. Also, `(ϵ, a)` is `a`.

In this round, after adding all the new elements, we end up with the set:   
{ ϵ, a, b, (a, a), (a, b), (b, a), (b, b) }

In the next round, we keep adding elements like (a, (a, b)), ((a, b), a), etc. At this point, we'll have to make sure that associativity holds, so we'll identify `(a, (b, a))` with `((a, b), a)`, etc. In other words, we can elide the need for internal parentheses.

This process goes forever, but eventually (after forever), we will have created all possible lists of `a`s and `b`s. In fact, if we represent `ϵ` as an empty list, we can see that this "multiplication" is list concatenation.

This kind of construction, in which you keep generating all possible combinations of elements, and perform the minimum number of identifications - just enough to uphold the laws - is called a **free construction**. What we have just *constructed is a free monoid from the generator set*, {a, b}.

## Free Monoid in Haskell

Ignoring problems with infinite lists, a two-element set in Haskell is equivalent to the type `Bool`, and the free monoid generated by this set is equivalent to the type [Bool].

A monoid in Haskell is defined by the type class:

```hs
class Monoid m where
  mempty  :: m
  mappend :: m -> m -> m

-- lists form a monoid:
instance Monoid [a] where
  mempty  = []
  mappend = (++)
```

As we have seen, `[a]` corresponds to a free monoid with the elements of the set `a` serving as generators, [a] ~ `Set a`.

The set of natural numbers with multiplication is not a free monoid, because we identify lots of products. Compare for instance:

```hs
2 * 3 = 6
[2] ++ [3] = [2, 3] -- not the same as [6]
```

The question is:
>Can we perform this free construction in category theory, where we are not allowed to look inside objects?

We can, and for that we use our workhorse, **the universal construction**.

The second interesting question is:
>Can any monoid be obtained from some free monoid by identifying more than the minimum number of elements required by the laws?

It will be shown that this follows directly from the universal construction.

## Universal construction of a free monoid

From our previous experiences with universal constructions, you might notice that it is not so much about constructing something, as about selecting an object that best fits a given pattern. So if we want to use the universal construction to "construct" a free monoid, we have to consider a whole bunch of monoids from which to pick one. We need a whole category of monoids to chose from. But do monoids form a category?

Let's first look at monoids as sets equipped with additional structure defined by unit and multiplication. We pick as morphisms those functions that preserve the monoidal structure. Such structure-preserving functions are called **homomorphisms**. A monoid homomorphism must map the product of two elements to the product of the mapping of the two elements:

    h (a * b) = h a * h b

and it must map unit to unit.

For instance, consider a homomorphism from [Int] to Int. If we map [2] to 2 and [3] to 3, we have to map [2, 3] to 6, because concat, [2] ++ [3] = [2, 3], becomes multiplication, 2 * 3 = 6.

Let's now forget about the internal structure of individual monoids, and only concentrate on them as objects with corresponding morphisms: we get a category `Mon` of monoids.

Before we forget about their internal structure, notice an important property: every object of `Mon` can be trivially mapped to a set. It is just the set of its elements. This set is called the *carrier or underlying set*. In fact, not only can we map objects of Mon to sets, but we can also map morphisms of Mon (homomorphisms) to functions.

Again, this seems sort of trivial, but it will become useful soon. This mapping of objects and morphisms from `Mon` to `Set` is in fact a functor. Since this functor "forgets" the monoidal structure - once we are inside a plain set, we can no longer distinguish the unit element or care about multiplication - it is called a **forgetful functor**.

We now have two different views of `Mon`. We can treat it just like any other category with objects and morphisms. In that view, we don't see the internal structure of monoids. All we can say about a particular object in Mon is that it connects to itself and to other objects through morphisms.

The "multiplication" table of morphisms - the composition rules - are derived from the other view: *monoids-as-sets*. By going to category theory we haven't lost this view completely - we can still access it through a forgetful functor.

To apply the universal construction, we need to define a special property that would let us search through the category of monoids and pick the best candidate for a free monoid. But a free monoid is defined by its generators. Different choices of generators produce different free monoids ([Bool] is not the same as [Int]). Our construction must start with a set of generators. So back to sets.

This is where the forgetful functor comes into play. We can use it to x-ray our monoids. We can identify the generators in the x-ray images of those blobs.

Here is how it works:
- We start with a set of generators, `x`, which is a set in `Set`.
- The pattern we are going to match against consists of a monoid `m ∈ Ob(Mon)` and a function `p ∈ Ar(Set)`, `p : x -> U m`, where `U : Mon -> Set` is the forgetful functor. This is a weird heterogeneous pattern - half in Mon and half in Set.

The idea is that the function `p` will identify the set of generators inside the x-ray image of `m`. It doesn't matter that functions may be bad at identifying points of sets (they may collapse them); all will be sorted by the universal construction, which will pick the best representative of this pattern.

We also have to define the *ranking among the candidates*.

Suppose we have another candidate - a monoid `n` and a function that identifies the generators in its x-ray image:

    q : x -> U n

We say that `m` is better than `n` if there is a morphism of monoids (i.e. a homomorphism):

    h : m -> n

whose image under `U` (U is a functor, so it maps morphisms to functions) factorizes through `p`:

    q = U h ∘ p

If you think of `p` as selecting the generators in `m`, and `q` as selecting "the same" generators in `n`, then you can think of `h` as mapping these generators between the two monoids.

Remember that `h`, by definition, preserves the monoidal structure, which means that a product of two generators in one monoid is mapped to a product of the corresponding two generators in the second monoid, and so on.

This ranking may be used to find the best candidate - the free monoid.

Here's the definition:

>The monoid `m` (together with the function `p`) is the **free monoid** with the generators `x`, iff there is a *unique morphism* `h` from `m` to any other monoid `n` (together with the function `q`) that satisfies the factorization property, `q = U h ∘ p`.


Incidentally, this answers our second question. The function `U h` is the one that has the power to collapse multiple elements of `U m` to a single element of `U n`. This collapse corresponds to identifying some elements of the free monoid. Therefore any monoid with generators `x` can be obtained from the free monoid based on `x` by identifying some of the elements. The free monoid is the one where only the bare minimum of identifications have been made.


You might think that the requirement that a homomorphism of monoids preserve the unit is redundant. After all, we know that

`∀a. h a • h e = h (a • e) = h a`

So `h e` acts like the *right unit* (and also as the left unit). The problem is that `h a`, for all `a`, might only cover a *sub-monoid* of the target monoid. There may be a "true" unit outside of the image of `h`.

>An isomorphism (homomorphism) between monoids that preserves multiplication must automatically preserve unit.

(M, •, ϵ) -----h----> (N, ★, η)

- h (a • b) = h a ★ h b

- h ϵ = η




## Homomorphisms

>A *homomorphism* maps a monoid to a monoid preserving unit and multiplication.

`(M, •, ϵ) -----h----> (N, ★, η)`
- `h ϵ = η`
- `h (a • b) = h a ★ h b`


## Example: Mapping between monoids

The monoid of list of naturals with concat to the monoid of ℕ with mult.

```
([ℕ], ++, []) -----h----> (ℕ, *, 1)

h [] = 1
h (a ++ b) = h a * h b

[] ⟼ 1
[0] ⟼ 0
[1] ⟼ 1
[2] ⟼ 2
[n] ⟼ n
[0,…] ⟼ 0
[1,2] ⟼ 1 * 2 = 2
[1,2,3] ⟼ 1 * 2 * 3 = 6
[1,2,3,4] ⟼ 24
[2,1] ⟼ 2 * 1 = 2
[3,2,1] ⟼ 3 * 2 * 1 = 6
[2,5,6] ⟼ 2 * 5 * 6 = 60

[1,12] ⟼ 12
[2,6]  ⟼ 12
[3,4]  ⟼ 12
[4,3]  ⟼ 12
[6,2]  ⟼ 12
[12,1] ⟼ 12

[]  ⟼ 1
[5] ⟼ 5

h  a  ++  h ϵ = h (a * ϵ) = h a
h [5] ++ h [] = h (5 * 1) = h 5

```


## Ref

* Free Monoids
https://bartoszmilewski.com/2015/07/21/free-monoids/

* notes on Milewski's CTFP
https://github.com/rpeszek/notes-milewski-ctfp-hs/wiki/N_P2Ch03_FreeMonoidFoldMap

https://ncatlab.org/nlab/show/monoid
https://ncatlab.org/nlab/show/monoidal+category
https://ncatlab.org/nlab/show/monoid+in+a+monoidal+category
https://ncatlab.org/nlab/show/strict+monoidal+category
https://ncatlab.org/nlab/show/coherence+theorem+for+monoidal+categories
https://ncatlab.org/nlab/show/free+monoid
https://ncatlab.org/nlab/show/homomorphism
https://ncatlab.org/nlab/show/category+of+monoids

https://en.wikipedia.org/wiki/Kleene_star
https://en.wikipedia.org/wiki/Free_monoid
https://en.wikipedia.org/wiki/Free_object
