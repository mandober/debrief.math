---
downloaded:       2021-12-18
page-url:         https://en.wikipedia.org/wiki/Computation_tree_logic
page-title:       Computation tree logic - Wikipedia
article-title:    Computation tree logic - Wikipedia
---
# Computation tree logic - Wikipedia

Computation tree logic (CTL) is a branching-time logic, meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. It is used in formal verification of software or hardware artifacts, typically by software applications known as model checkers, which determine if a given artifact possesses safety or liveness properties. For example, CTL can specify that when some initial condition is satisfied (e.g., all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g., dividing a number by zero or two cars colliding on a highway). In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property. Computation tree logic belongs to a class of temporal logics that includes linear temporal logic (LTL). Although there are properties expressible only in CTL and properties expressible only in LTL, all properties expressible in either logic can also be expressed in CTL*.
__Computation tree logic__ (__CTL__) is a branching-time [logic][1], meaning that its model of [time][2] is a [tree-like][3] structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. It is used in [formal verification][4] of software or hardware artifacts, typically by software applications known as [model checkers][5], which determine if a given artifact possesses [safety][6] or [liveness][7] properties. For example, CTL can specify that when some initial condition is satisfied (e.g., all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g., dividing a number by zero or two cars colliding on a highway). In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property. Computation tree logic belongs to a class of [temporal logics][8] that includes [linear temporal logic][9] (LTL). Although there are properties expressible only in CTL and properties expressible only in LTL, all properties expressible in either logic can also be expressed in [CTL\*][10].

CTL was first proposed by [Edmund M. Clarke][11] and [E. Allen Emerson][12] in 1981, who used it to synthesize so-called *synchronisation skeletons*, *i.e* abstractions of [concurrent programs][13].

## Syntax of CTL\[[edit][14]\]

The [language][15] of [well-formed formulas][16] for CTL is generated by the following [grammar][17]:

![{\displaystyle {\begin{aligned}\phi &::=\bot \mid \top \mid p\mid (\neg \phi )\mid (\phi \land \phi )\mid (\phi \lor \phi )\mid (\phi \Rightarrow \phi )\mid (\phi \Leftrightarrow \phi )\\&\mid \quad {\mbox{AX }}\phi \mid {\mbox{EX }}\phi \mid {\mbox{AF }}\phi \mid {\mbox{EF }}\phi \mid {\mbox{AG }}\phi \mid {\mbox{EG }}\phi \mid {\mbox{A }}[\phi {\mbox{ U }}\phi ]\mid {\mbox{E }}[\phi {\mbox{ U }}\phi ]\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/534ec347982ee3cda15039732fb05aa9e3ebc7bf)

where ![p](https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36) ranges over a set of [atomic formulas][18]. It is not necessary to use all connectives – for example, ![{\displaystyle \{\neg ,\land ,{\mbox{AX}},{\mbox{AU}},{\mbox{EU}}\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6ce47e80e79ce95a03e45a473446e21b39c5657b) comprises a complete set of connectives, and the others can be defined using them.

For example, the following is a well-formed CTL formula:

![\mbox{EF }(\mbox{EG } p \Rightarrow \mbox{AF } r ](https://wikimedia.org/api/rest_v1/media/math/render/svg/76e7199c51eb133e844b15afaaafa546d0f34a55))

The following is not a well-formed CTL formula:

![\mbox{EF }\big(r \mbox{ U } q\big) ](https://wikimedia.org/api/rest_v1/media/math/render/svg/60410d0de68554a35819ca1cf29626d8d46498da)

The problem with this string is that ![U](https://wikimedia.org/api/rest_v1/media/math/render/svg/458a728f53b9a0274f059cd695e067c430956025) can occur only when paired with an ![A](https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3) or an ![E](https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b).

CTL uses [atomic propositions][19] as its building blocks to make statements about the states of a system. These propositions are then combined into formulas using [logical operators][20] and [temporal operators][21].

## Operators\[[edit][22]\]

### Logical operators\[[edit][23]\]

The [logical operators][24] are the usual ones: ¬, ∨, ∧, ⇒ and ⇔. Along with these operators CTL formulas can also make use of the boolean constants [true][25] and [false][26].

### Temporal operators\[[edit][27]\]

The temporal operators are the following:

-   Quantifiers over paths
    -   __A__ Φ – __A__ll: Φ has to hold on all paths starting from the current state.
    -   __E__ Φ – __E__xists: there exists at least one path starting from the current state where Φ holds.
-   Path-specific quantifiers
    -   __X__ *φ* – Ne__x__t: *φ* has to hold at the next state (this operator is sometimes noted __N__ instead of __X__).
    -   __G__ *φ* – __G__lobally: *φ* has to hold on the entire subsequent path.
    -   __F__ *φ* – __F__inally: *φ* eventually has to hold (somewhere on the subsequent path).
    -   *φ* __U__ *ψ* – __U__ntil: *φ* has to hold *at least* until at some position *ψ* holds. This implies that *ψ* will be verified in the future.
    -   *φ* __W__ *ψ* – __W__eak until: *φ* has to hold until *ψ* holds. The difference with __U__ is that there is no guarantee that *ψ* will ever be verified. The __W__ operator is sometimes called "unless".

In [CTL\*][28], the temporal operators can be freely mixed. In CTL, the operator must always be grouped in two: one path operator followed by a state operator. See the examples below. [CTL\*][29] is strictly more expressive than CTL.

### Minimal set of operators\[[edit][30]\]

In CTL there are minimal sets of operators. All CTL formulas can be transformed to use only those operators. This is useful in [model checking][31]. One minimal set of operators is: {true, ∨, ¬, __EG__, __EU__, __EX__}.

Some of the transformations used for temporal operators are:

-   __EF__*φ* == __E__\[true__U__(*φ*)\] ( because __F__*φ* == \[true__U__(*φ*)\] )
-   __AX__*φ* == ¬__EX__(¬*φ*)
-   __AG__*φ* == ¬__EF__(¬*φ*) == ¬ __E__\[true__U__(¬*φ*)\]
-   __AF__*φ* == __A__\[true__U__*φ*\] == ¬__EG__(¬*φ*)
-   __A__\[*φ*__U__*ψ*\] == ¬( __E__\[(¬*ψ*)__U__¬(*φ*∨*ψ*)\] ∨ __EG__(¬*ψ*) )

## Semantics of CTL\[[edit][32]\]

### Definition\[[edit][33]\]

CTL formulae are interpreted over [transition system][34]. A transition system is a triple ![{\displaystyle {\mathcal {M}}=(S,{\rightarrow },L)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/40a7b2629e5a1b0764ddaedd1c303c6a907c9a45), where ![S](https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2) is a set of states, ![{\displaystyle {\rightarrow }\subseteq S\times S}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1dea57cc7257730f5787c2ff9335376e420c0c54) is a transition relation, assumed to be serial, i.e. every state has at least one successor, and ![L](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8) is a labelling function, assigning propositional letters to states. Let ![\mathcal{M}=(S,\rightarrow,L)](https://wikimedia.org/api/rest_v1/media/math/render/svg/61149a3f0713302d68a0847aa068b2d690ad7a83) be such a transition model

with ![s \in S, \phi \in F](https://wikimedia.org/api/rest_v1/media/math/render/svg/00755588b145af33eca272b9569b2ce841e97767) where F is the set of [wffs][35] over the [language][36] of ![{\mathcal {M}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2cc2abebd45ec020509a0ec548b67c9a2cb7cecd).

Then the relation of semantic [entailment][37] ![(\mathcal{M}, s \models \phi)](https://wikimedia.org/api/rest_v1/media/math/render/svg/70925759561d826a66137c5130c40ed8c21b5d1b) is defined recursively on ![\phi ](https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4):

1.  ![{\Big (}({\mathcal {M}},s)\models \top {\Big )}\land {\Big (}({\mathcal {M}},s)\not \models \bot {\Big )}](https://wikimedia.org/api/rest_v1/media/math/render/svg/33f267a82d4b3171584ebc4223c8dcf4dda9dc6f)
2.  ![{\Big (}({\mathcal {M}},s)\models p{\Big )}\Leftrightarrow {\Big (}p\in L(s){\Big )}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3a05f2e40a319619c299b98b816d4e41b6e89e77)
3.  ![\Big( (\mathcal{M}, s) \models \neg\phi \Big) \Leftrightarrow \Big( (\mathcal{M}, s) \not\models \phi \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/d9bf165c6200589eaa928c919b0a4ef136446be9)
4.  ![\Big( (\mathcal{M}, s) \models \phi_1 \land \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \land \big((\mathcal{M}, s) \models \phi_2 \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/49a632344275698cb913d1952d0fa7314106f319)
5.  ![\Big( (\mathcal{M}, s) \models \phi_1 \lor \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \lor \big((\mathcal{M}, s) \models \phi_2 \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/297daf314bded9e1bd8aa70f52125239147b3208)
6.  ![\Big( (\mathcal{M}, s) \models \phi_1 \Rightarrow \phi_2 \Big) \Leftrightarrow \Big( \big((\mathcal{M}, s) \not\models \phi_1 \big) \lor \big((\mathcal{M}, s) \models \phi_2 \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/9f32b0b8faa4b9737f0443773e54673a5b394348)
7.  ![\bigg( (\mathcal{M}, s) \models \phi_1 \Leftrightarrow \phi_2 \bigg) \Leftrightarrow \bigg( \Big( \big((\mathcal{M}, s) \models \phi_1 \big) \land \big((\mathcal{M}, s) \models \phi_2 \big) \Big) \lor \Big( \neg \big((\mathcal{M}, s) \models \phi_1 \big) \land \neg \big((\mathcal{M}, s) \models \phi_2 \big) \Big) \bigg)](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7967db0b63692f7fa32ab04fea295d3117b967e)
8.  ![\Big( (\mathcal{M}, s) \models AX\phi \Big) \Leftrightarrow \Big( \forall \langle s \rightarrow s_1 \rangle \big( (\mathcal{M}, s_1) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/b3c039594592d6766cdf664ae23229f2822e049e)
9.  ![\Big( (\mathcal{M}, s) \models EX\phi \Big) \Leftrightarrow \Big( \exists \langle s \rightarrow s_1 \rangle \big( (\mathcal{M}, s_1) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/2ffa515f4d36691664ef1148c1c1ac3fcd8367d2)
10.  ![\Big( (\mathcal{M}, s) \models AG\phi \Big) \Leftrightarrow \Big( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \forall i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/8ffdff10ab7d1509889225841a053d6e64ab8f4b)
11.  ![\Big( (\mathcal{M}, s) \models EG\phi \Big) \Leftrightarrow \Big( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \forall i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/5c073f861d459fd9cf0304e1fcc26b01fa1f7619)
12.  ![\Big( (\mathcal{M}, s) \models AF\phi \Big) \Leftrightarrow \Big( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/332acc1e3685a7e38a1ba5798babf5dd1edf6746)
13.  ![\Big( (\mathcal{M}, s) \models EF\phi \Big) \Leftrightarrow \Big( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \big( (\mathcal{M}, s_i) \models \phi \big) \Big)](https://wikimedia.org/api/rest_v1/media/math/render/svg/93838e53fe87922a77b2f669d8fb4466ff63beda)
14.  ![\bigg( (\mathcal{M}, s) \models A[\phi_1 U \phi_2] \bigg) \Leftrightarrow \bigg( \forall \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \Big( \big( (\mathcal{M}, s_i) \models \phi_2 \big) \land \big( \forall (j < i) (\mathcal{M}, s_j) \models \phi_1 \big) \Big) \bigg)](https://wikimedia.org/api/rest_v1/media/math/render/svg/3dcde0c80e048ab8a9f89e4d75f5c94aea75a6f3)
15.  ![\bigg( (\mathcal{M}, s) \models E[\phi_1 U \phi_2] \bigg) \Leftrightarrow \bigg( \exists \langle s_1 \rightarrow s_2 \rightarrow \ldots \rangle (s=s_1) \exists i \Big( \big( (\mathcal{M}, s_i) \models \phi_2 \big) \land \big( \forall (j < i) (\mathcal{M}, s_j) \models \phi_1 \big) \Big) \bigg)](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d04777cb8e0ba5d53918b4b64927615b6fefc1a)

### Characterisation of CTL\[[edit][38]\]

Rules 10–15 above refer to computation paths in models and are what ultimately characterise the "Computation Tree"; they are assertions about the nature of the infinitely deep computation tree rooted at the given state ![s](https://wikimedia.org/api/rest_v1/media/math/render/svg/01d131dfd7673938b947072a13a9744fe997e632).

### Semantic equivalences\[[edit][39]\]

The formulae ![\phi ](https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4) and ![\psi ](https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a) are said to be semantically equivalent if any state in any model that satisfies one also satisfies the other. This is denoted ![\phi \equiv \psi](https://wikimedia.org/api/rest_v1/media/math/render/svg/6786212cdc76b6ec6fe76bae5c2facaa1874f70b)

It can be seen that A and E are duals, being universal and existential computation path quantifiers respectively: ![{\displaystyle \neg A\Phi \equiv E\neg \Phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/bbae087de7950dd6444a078625f059bc019f3545).

Furthermore, so are G and F.

Hence an instance of [De Morgan's laws][40] can be formulated in CTL:

![\neg AF\phi \equiv EG\neg\phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/18e2f03724a1739d0c69b4bb75f080ba1424c65b)

![\neg EF\phi \equiv AG\neg\phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/25b3864276c430af2973d13420c63562972fa5a1)

![\neg AX\phi \equiv EX\neg\phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/778b6bd72e8747e61b47b3d7ed256376a6c77b30)

It can be shown using such identities that a subset of the CTL temporal connectives is adequate if it contains ![EU](https://wikimedia.org/api/rest_v1/media/math/render/svg/0540f98b65a648c9f2711f2712b36120ae3b910d), at least one of ![\{AX,EX\}](https://wikimedia.org/api/rest_v1/media/math/render/svg/90780c46e83b9620f0b74e98798daa238d940876) and at least one of ![\{EG,AF,AU\}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f200e4eeec0c6ec39860e01cc92f6ef61d2d7db) and the boolean connectives.

The important equivalences below are called the __expansion laws__; they allow to unfold the verification of a CTL connective towards its successors in time.

![AG\phi \equiv \phi \land AX AG \phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/f0364fe35455e99a8b8921b6e2b662ed69ce731e)

![EG\phi \equiv \phi \land EX EG \phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/3f8a3c8d890e863d14685d05b2c47e1ff2ceb01a)

![AF\phi \equiv \phi \lor AX AF \phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/ac867ff99f6db222225dd052ab3979c819036419)

![EF\phi \equiv \phi \lor EX EF \phi](https://wikimedia.org/api/rest_v1/media/math/render/svg/83c1396dd5043b477b86fcbef6a1e6936213e14f)

![A[\phi U \psi] \equiv \psi \lor (\phi \land AX A [\phi U \psi])](https://wikimedia.org/api/rest_v1/media/math/render/svg/04e432a4e05e0f27a955be8f1520f6746e653517)

![E[\phi U \psi] \equiv \psi \lor (\phi \land EX E [\phi U \psi])](https://wikimedia.org/api/rest_v1/media/math/render/svg/1e5839bd0d5c32f192612cb8ed45733343e15442)

## Examples\[[edit][41]\]

Let "P" mean "I like chocolate" and Q mean "It's warm outside."

-   __AG__.P

"I will like chocolate from now on, no matter what happens."

-   __EF__.P

"It's possible I may like chocolate some day, at least for one day."

-   __AF__.__EG__.P

"It's always possible (AF) that I will suddenly start liking chocolate for the rest of time." (Note: not just the rest of my life, since my life is finite, while __G__ is infinite).

-   __EG__.__AF__.P

"Depending on what happens in the future (E), it's possible that for the rest of time (G), I'll be guaranteed at least one (AF) chocolate-liking still ahead of me. However, if something ever goes wrong, then all bets are off and there's no guarantee about whether I'll ever like chocolate."

The two following examples show the difference between CTL and CTL\*, as they allow for the until operator to not be qualified with any path operator (__A__ or __E__):

-   __AG__(P__U__Q)

"From now until it's warm outside, I will like chocolate every single day. Once it's warm outside, all bets are off as to whether I'll like chocolate anymore. Oh, and it's guaranteed to be warm outside eventually, even if only for a single day."

-   __EF__((__EX__.P)__U__(__AG__.Q))

"It's possible that: there will eventually come a time when it will be warm forever (AG.Q) and that before that time there will always be *some* way to get me to like chocolate the next day (EX.P)."

## Relations with other logics\[[edit][42]\]

Computation tree logic (CTL) is a subset of CTL\* as well as of the [modal μ calculus][43]. CTL is also a fragment of Alur, Henzinger and Kupferman's [alternating-time temporal logic][44] (ATL).

Computation tree logic (CTL) and [linear temporal logic][45] (LTL) are both a subset of CTL\*. CTL and [LTL][46] are not equivalent and they have a common subset, which is a proper subset of both CTL and LTL.

-   __FG__.P exists in LTL but not in CTL.
-   __AG__(P⇒((__EX__.Q)∧(__EX__¬Q))) and __AG.EF__.P exist in CTL but not in LTL.

## Extensions\[[edit][47]\]

CTL has been extended with second-order quantification ![{\displaystyle \exists p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3b2b8b0cd274f80eeade7b0c40438a5758bcafd7) and ![\forall p](https://wikimedia.org/api/rest_v1/media/math/render/svg/d0d457f5c70d5f2f1abbe20ba1903ab554916bd6) to quantified computational tree logic (QCTL).[\[1\]][48] There are two semantics:

-   the tree semantics. We label nodes of the computation tree. QCTL\* = QCTL = [MSO][49] over trees. Model checking and satisfiability are tower complete.
-   the structure semantics. We label states. QCTL\* = QCTL = MSO over [graphs][50]. Model checking is [PSPACE-complete][51] but satisfiability is [undecidable][52].

A reduction from the model-checking problem of QCTL with the structure semantics, to TQBF (true quantified Boolean formulae) has been proposed, in order to take advantage of the QBF solvers.[\[2\]][53]

## See also\[[edit][54]\]

-   [Probabilistic CTL][55]
-   [Fair computational tree logic][56]
-   [Linear temporal logic][57]

## References\[[edit][58]\]

1.  __[^][59]__ David, Amélie; Laroussinie, Francois; Markey, Nicolas (2016). Desharnais, Josée; Jagadeesan, Radha (eds.). ["On the Expressiveness of QCTL"][60]. *27th International Conference on Concurrency Theory (CONCUR 2016)*. Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. __59__: 28:1–28:15. [doi][61]:[10.4230/LIPIcs.CONCUR.2016.28][62]. [ISBN][63] [978-3-95977-017-0][64].
2.  __[^][65]__ Hossain, Akash; Laroussinie, François (2019). Gamper, Johann; Pinchinat, Sophie; Sciavicco, Guido (eds.). ["From Quantified CTL to QBF"][66]. *26th International Symposium on Temporal Representation and Reasoning (TIME 2019)*. Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik. __147__: 11:1–11:20. [doi][67]:[10.4230/LIPIcs.TIME.2019.11][68]. [ISBN][69] [978-3-95977-127-6][70].

-   E.M. Clarke; E.A. Emerson (1981). ["Design and synthesis of synchronisation skeletons using branching time temporal logic"][71] (PDF). *Logic of Programs, Proceedings of Workshop, Lecture Notes in Computer Science*. Springer, Berlin. __131__: 52–71.
-   Michael Huth; Mark Ryan (2004). *Logic in Computer Science (Second Edition)*. Cambridge University Press. p. 207. [ISBN][72] [978-0-521-54310-1][73].
-   Emerson, E. A.; Halpern, J. Y. (1985). "Decision procedures and expressiveness in the temporal logic of branching time". *Journal of Computer and System Sciences*. __30__ (1): 1–24. [doi][74]:[10.1016/0022-0000(85)90001-7][75].
-   Clarke, E. M.; Emerson, E. A. & Sistla, A. P. (1986). "Automatic verification of finite-state concurrent systems using temporal logic specifications". *ACM Transactions on Programming Languages and Systems*. __8__ (2): 244–263. [doi][76]:[10.1145/5397.5399][77].
-   Emerson, E. A. (1990). "Temporal and modal logic". In [Jan van Leeuwen][78] (ed.). *Handbook of Theoretical Computer Science, vol. B*. MIT Press. pp. 955–1072. [ISBN][79] [978-0-262-22039-2][80].

## External links\[[edit][81]\]

-   [Teaching slides of CTL][82]

[1]: https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic"
[2]: https://en.wikipedia.org/wiki/Time "Time"
[3]: https://en.wikipedia.org/wiki/Tree_(graph_theory) "Tree (graph theory)"
[4]: https://en.wikipedia.org/wiki/Formal_verification "Formal verification"
[5]: https://en.wikipedia.org/wiki/Model_checker "Model checker"
[6]: https://en.wikipedia.org/wiki/Safety_(distributed_computing) "Safety (distributed computing)"
[7]: https://en.wikipedia.org/wiki/Liveness "Liveness"
[8]: https://en.wikipedia.org/wiki/Temporal_logic "Temporal logic"
[9]: https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic"
[10]: https://en.wikipedia.org/wiki/CTL* "CTL*"
[11]: https://en.wikipedia.org/wiki/Edmund_M._Clarke "Edmund M. Clarke"
[12]: https://en.wikipedia.org/wiki/E._Allen_Emerson "E. Allen Emerson"
[13]: https://en.wikipedia.org/wiki/Concurrent_program "Concurrent program"
[14]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=1 "Edit section: Syntax of CTL"
[15]: https://en.wikipedia.org/wiki/Regular_Language "Regular Language"
[16]: https://en.wikipedia.org/wiki/Well-formed_formula "Well-formed formula"
[17]: https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar"
[18]: https://en.wikipedia.org/wiki/Atomic_formula "Atomic formula"
[19]: https://en.wikipedia.org/wiki/First-order_logic#Vocabulary "First-order logic"
[20]: https://en.wikipedia.org/wiki/Logical_operator "Logical operator"
[21]: https://en.wikipedia.org/wiki/Temporal_logic "Temporal logic"
[22]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=2 "Edit section: Operators"
[23]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=3 "Edit section: Logical operators"
[24]: https://en.wikipedia.org/wiki/Logical_connective "Logical connective"
[25]: https://en.wikipedia.org/wiki/Truth "Truth"
[26]: https://en.wikipedia.org/wiki/False_(logic) "False (logic)"
[27]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=4 "Edit section: Temporal operators"
[28]: https://en.wikipedia.org/wiki/CTL* "CTL*"
[29]: https://en.wikipedia.org/wiki/CTL* "CTL*"
[30]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=5 "Edit section: Minimal set of operators"
[31]: https://en.wikipedia.org/wiki/Model_checking "Model checking"
[32]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=6 "Edit section: Semantics of CTL"
[33]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=7 "Edit section: Definition"
[34]: https://en.wikipedia.org/wiki/Transition_system "Transition system"
[35]: https://en.wikipedia.org/wiki/Well_formed_formula "Well formed formula"
[36]: https://en.wikipedia.org/wiki/Regular_Language "Regular Language"
[37]: https://en.wikipedia.org/wiki/Entailment "Entailment"
[38]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=8 "Edit section: Characterisation of CTL"
[39]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=9 "Edit section: Semantic equivalences"
[40]: https://en.wikipedia.org/wiki/De_Morgan%27s_laws "De Morgan's laws"
[41]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=10 "Edit section: Examples"
[42]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=11 "Edit section: Relations with other logics"
[43]: https://en.wikipedia.org/wiki/Modal_mu_calculus "Modal mu calculus"
[44]: https://en.wikipedia.org/wiki/Alternating-time_temporal_logic "Alternating-time temporal logic"
[45]: https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic"
[46]: https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic"
[47]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=12 "Edit section: Extensions"
[48]: https://en.wikipedia.org/wiki/Computation_tree_logic#cite_note-1
[49]: https://en.wikipedia.org/wiki/Monadic_second-order_logic "Monadic second-order logic"
[50]: https://en.wikipedia.org/wiki/Graph_(discrete_mathematics) "Graph (discrete mathematics)"
[51]: https://en.wikipedia.org/wiki/PSPACE-complete "PSPACE-complete"
[52]: https://en.wikipedia.org/wiki/Undecidable_problem "Undecidable problem"
[53]: https://en.wikipedia.org/wiki/Computation_tree_logic#cite_note-2
[54]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=13 "Edit section: See also"
[55]: https://en.wikipedia.org/wiki/Probabilistic_CTL "Probabilistic CTL"
[56]: https://en.wikipedia.org/wiki/Fair_computational_tree_logic "Fair computational tree logic"
[57]: https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic"
[58]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=14 "Edit section: References"
[59]: https://en.wikipedia.org/wiki/Computation_tree_logic#cite_ref-1
[60]: http://drops.dagstuhl.de/opus/volltexte/2016/6164
[61]: https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"
[62]: https://doi.org/10.4230%2FLIPIcs.CONCUR.2016.28
[63]: https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)"
[64]: https://en.wikipedia.org/wiki/Special:BookSources/978-3-95977-017-0 "Special:BookSources/978-3-95977-017-0"
[65]: https://en.wikipedia.org/wiki/Computation_tree_logic#cite_ref-2
[66]: http://drops.dagstuhl.de/opus/volltexte/2019/11369
[67]: https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"
[68]: https://doi.org/10.4230%2FLIPIcs.TIME.2019.11
[69]: https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)"
[70]: https://en.wikipedia.org/wiki/Special:BookSources/978-3-95977-127-6 "Special:BookSources/978-3-95977-127-6"
[71]: https://www.cs.cmu.edu/afs/cs/user/emc/www/papers/Invited%20Conference%20Articles/Design%20and%20Synthesis%20of%20Synchronization%20Skeletons%20Using%20Branching%20Time%20Temporal%20Logic.pdf
[72]: https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)"
[73]: https://en.wikipedia.org/wiki/Special:BookSources/978-0-521-54310-1 "Special:BookSources/978-0-521-54310-1"
[74]: https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"
[75]: https://doi.org/10.1016%2F0022-0000%2885%2990001-7
[76]: https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"
[77]: https://doi.org/10.1145%2F5397.5399
[78]: https://en.wikipedia.org/wiki/Jan_van_Leeuwen "Jan van Leeuwen"
[79]: https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)"
[80]: https://en.wikipedia.org/wiki/Special:BookSources/978-0-262-22039-2 "Special:BookSources/978-0-262-22039-2"
[81]: https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=15 "Edit section: External links"
[82]: http://www.inf.unibz.it/~artale/FM/slide4.pdf
